// @generated - This file is generated by atrium-codegen. DO NOT EDIT.
//!Structs for ATP client, implements all HTTP APIs of XRPC.
///Client struct for the ATP service.
pub struct AtpServiceClient<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub service: Service<T>,
}
impl<T> AtpServiceClient<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub fn new(xrpc: T) -> Self {
        Self {
            service: Service::new(std::sync::Arc::new(xrpc)),
        }
    }
}
pub struct Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub blue: blue::Service<T>,
    pub(crate) _phantom: core::marker::PhantomData<T>,
}
pub mod blue {
    pub struct Service<T>
    where
        T: atrium_xrpc::XrpcClient + Send + Sync,
    {
        #[cfg_attr(docsrs, doc(cfg(feature = "namespace-bluecatbird")))]
        #[cfg(feature = "namespace-bluecatbird")]
        pub catbird: catbird::Service<T>,
        pub(crate) _phantom: core::marker::PhantomData<T>,
    }
    #[cfg_attr(docsrs, doc(cfg(feature = "namespace-bluecatbird")))]
    #[cfg(feature = "namespace-bluecatbird")]
    pub mod catbird {
        pub struct Service<T>
        where
            T: atrium_xrpc::XrpcClient + Send + Sync,
        {
            pub mls: mls::Service<T>,
            pub(crate) _phantom: core::marker::PhantomData<T>,
        }
        pub mod mls {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
                pub(crate) _phantom: core::marker::PhantomData<T>,
            }
        }
    }
}
impl<T> self::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            blue: blue::Service::new(std::sync::Arc::clone(&xrpc)),
            _phantom: core::marker::PhantomData,
        }
    }
}
impl<T> blue::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            #[cfg(feature = "namespace-bluecatbird")]
            catbird: blue::catbird::Service::new(std::sync::Arc::clone(&xrpc)),
            _phantom: core::marker::PhantomData,
        }
    }
}
#[cfg(feature = "namespace-bluecatbird")]
impl<T> blue::catbird::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            mls: blue::catbird::mls::Service::new(std::sync::Arc::clone(&xrpc)),
            _phantom: core::marker::PhantomData,
        }
    }
}
#[cfg(feature = "namespace-bluecatbird")]
impl<T> blue::catbird::mls::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            xrpc,
            _phantom: core::marker::PhantomData,
        }
    }
    ///Add members to an existing MLS conversation
    pub async fn add_members(
        &self,
        input: crate::blue::catbird::mls::add_members::Input,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::add_members::Output,
        crate::blue::catbird::mls::add_members::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::blue::catbird::mls::add_members::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Create a new MLS conversation
    pub async fn create_convo(
        &self,
        input: crate::blue::catbird::mls::create_convo::Input,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::create_convo::Output,
        crate::blue::catbird::mls::create_convo::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::blue::catbird::mls::create_convo::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Query to fetch user's MLS conversations
    pub async fn get_convos(
        &self,
        params: crate::blue::catbird::mls::get_convos::Parameters,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::get_convos::Output,
        crate::blue::catbird::mls::get_convos::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::blue::catbird::mls::get_convos::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Retrieve key packages for one or more DIDs to add them to conversations
    pub async fn get_key_packages(
        &self,
        params: crate::blue::catbird::mls::get_key_packages::Parameters,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::get_key_packages::Output,
        crate::blue::catbird::mls::get_key_packages::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::blue::catbird::mls::get_key_packages::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Retrieve messages from an MLS conversation
    pub async fn get_messages(
        &self,
        params: crate::blue::catbird::mls::get_messages::Parameters,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::get_messages::Output,
        crate::blue::catbird::mls::get_messages::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::blue::catbird::mls::get_messages::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Leave an MLS conversation
    pub async fn leave_convo(
        &self,
        input: crate::blue::catbird::mls::leave_convo::Input,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::leave_convo::Output,
        crate::blue::catbird::mls::leave_convo::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::blue::catbird::mls::leave_convo::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Publish an MLS key package to enable others to add you to conversations
    pub async fn publish_key_package(
        &self,
        input: crate::blue::catbird::mls::publish_key_package::Input,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::publish_key_package::Output,
        crate::blue::catbird::mls::publish_key_package::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::blue::catbird::mls::publish_key_package::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Send an encrypted message to an MLS conversation
    pub async fn send_message(
        &self,
        input: crate::blue::catbird::mls::send_message::Input,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::send_message::Output,
        crate::blue::catbird::mls::send_message::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::blue::catbird::mls::send_message::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Upload a blob for later reference in messages or metadata
    pub async fn upload_blob(
        &self,
        input: Vec<u8>,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::upload_blob::Output,
        crate::blue::catbird::mls::upload_blob::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                Vec<u8>,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::blue::catbird::mls::upload_blob::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Bytes(input)),
                    encoding: Some(String::from("*/*")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
}
