// @generated by jacquard-lexicon. DO NOT EDIT.
//
// Lexicon: blue.catbird.mlsChat.declaration
//
// This file was automatically generated from Lexicon schemas.
// Any manual changes will be overwritten on the next regeneration.

/// Update chat policy settings
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    Default,
)]
#[serde(rename_all = "camelCase")]
pub struct ChatPolicyUpdate<'a> {
    /// Whether followers can bypass chat request approval
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub allow_followers_bypass: std::option::Option<bool>,
    /// Whether accounts this user follows can bypass chat request approval
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub allow_following_bypass: std::option::Option<bool>,
    /// Auto-expire pending requests after this many days (0 = no expiry)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub auto_expire_days: std::option::Option<i64>,
}

fn lexicon_doc_blue_catbird_mlsChat_declaration() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static>
{
    ::jacquard_lexicon::lexicon::LexiconDoc {
        lexicon: ::jacquard_lexicon::lexicon::Lexicon::Lexicon1,
        id: ::jacquard_common::CowStr::new_static("blue.catbird.mlsChat.declaration"),
        revision: None,
        description: None,
        defs: {
            let mut map = ::std::collections::BTreeMap::new();
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("chatPolicyUpdate"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(
                    ::jacquard_lexicon::lexicon::LexObject {
                        description: Some(::jacquard_common::CowStr::new_static(
                            "Update chat policy settings",
                        )),
                        required: None,
                        nullable: None,
                        properties: {
                            #[allow(unused_mut)]
                            let mut map = ::std::collections::BTreeMap::new();
                            map.insert(
                                ::jacquard_common::smol_str::SmolStr::new_static(
                                    "allowFollowersBypass",
                                ),
                                ::jacquard_lexicon::lexicon::LexObjectProperty::Boolean(
                                    ::jacquard_lexicon::lexicon::LexBoolean {
                                        description: None,
                                        default: None,
                                        r#const: None,
                                    },
                                ),
                            );
                            map.insert(
                                ::jacquard_common::smol_str::SmolStr::new_static(
                                    "allowFollowingBypass",
                                ),
                                ::jacquard_lexicon::lexicon::LexObjectProperty::Boolean(
                                    ::jacquard_lexicon::lexicon::LexBoolean {
                                        description: None,
                                        default: None,
                                        r#const: None,
                                    },
                                ),
                            );
                            map.insert(
                                ::jacquard_common::smol_str::SmolStr::new_static("autoExpireDays"),
                                ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(
                                    ::jacquard_lexicon::lexicon::LexInteger {
                                        description: None,
                                        default: None,
                                        minimum: Some(0i64),
                                        maximum: None,
                                        r#enum: None,
                                        r#const: None,
                                    },
                                ),
                            );
                            map
                        },
                    },
                ),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("deviceAdd"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(
                    ::jacquard_lexicon::lexicon::LexObject {
                        description: Some(::jacquard_common::CowStr::new_static(
                            "Add a device to the authorized set",
                        )),
                        required: Some(vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("deviceId"),
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "deviceMlsSignaturePublicKey",
                            ),
                        ]),
                        nullable: None,
                        properties: {
                            #[allow(unused_mut)]
                            let mut map = ::std::collections::BTreeMap::new();
                            map.insert(
                                ::jacquard_common::smol_str::SmolStr::new_static("deviceId"),
                                ::jacquard_lexicon::lexicon::LexObjectProperty::String(
                                    ::jacquard_lexicon::lexicon::LexString {
                                        description: Some(::jacquard_common::CowStr::new_static(
                                            "Device UUID identifier",
                                        )),
                                        format: None,
                                        default: None,
                                        min_length: None,
                                        max_length: None,
                                        min_graphemes: None,
                                        max_graphemes: None,
                                        r#enum: None,
                                        r#const: None,
                                        known_values: None,
                                    },
                                ),
                            );
                            map.insert(
                                ::jacquard_common::smol_str::SmolStr::new_static(
                                    "deviceMlsSignaturePublicKey",
                                ),
                                ::jacquard_lexicon::lexicon::LexObjectProperty::Bytes(
                                    ::jacquard_lexicon::lexicon::LexBytes {
                                        description: None,
                                        max_length: None,
                                        min_length: None,
                                    },
                                ),
                            );
                            map.insert(
                                ::jacquard_common::smol_str::SmolStr::new_static("deviceName"),
                                ::jacquard_lexicon::lexicon::LexObjectProperty::String(
                                    ::jacquard_lexicon::lexicon::LexString {
                                        description: Some(::jacquard_common::CowStr::new_static(
                                            "Human-readable device name",
                                        )),
                                        format: None,
                                        default: None,
                                        min_length: None,
                                        max_length: Some(128usize),
                                        min_graphemes: None,
                                        max_graphemes: None,
                                        r#enum: None,
                                        r#const: None,
                                        known_values: None,
                                    },
                                ),
                            );
                            map
                        },
                    },
                ),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("deviceProof"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Proof from the device being added, demonstrating possession of the device key",
                        ),
                    ),
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("proofSig"),
                            ::jacquard_common::smol_str::SmolStr::new_static("proofAlg")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::std::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("proofAlg"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Algorithm of the device proof signature",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("proofSig"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Bytes(::jacquard_lexicon::lexicon::LexBytes {
                                description: None,
                                max_length: None,
                                min_length: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("deviceRevoke"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(
                    ::jacquard_lexicon::lexicon::LexObject {
                        description: Some(::jacquard_common::CowStr::new_static(
                            "Revoke a device from the authorized set",
                        )),
                        required: None,
                        nullable: None,
                        properties: {
                            #[allow(unused_mut)]
                            let mut map = ::std::collections::BTreeMap::new();
                            map.insert(
                                ::jacquard_common::smol_str::SmolStr::new_static("deviceId"),
                                ::jacquard_lexicon::lexicon::LexObjectProperty::String(
                                    ::jacquard_lexicon::lexicon::LexString {
                                        description: Some(::jacquard_common::CowStr::new_static(
                                            "The revoked device's UUID",
                                        )),
                                        format: None,
                                        default: None,
                                        min_length: None,
                                        max_length: None,
                                        min_graphemes: None,
                                        max_graphemes: None,
                                        r#enum: None,
                                        r#const: None,
                                        known_values: None,
                                    },
                                ),
                            );
                            map.insert(
                                ::jacquard_common::smol_str::SmolStr::new_static(
                                    "deviceMlsSignaturePublicKey",
                                ),
                                ::jacquard_lexicon::lexicon::LexObjectProperty::Bytes(
                                    ::jacquard_lexicon::lexicon::LexBytes {
                                        description: None,
                                        max_length: None,
                                        min_length: None,
                                    },
                                ),
                            );
                            map.insert(
                                ::jacquard_common::smol_str::SmolStr::new_static("reason"),
                                ::jacquard_lexicon::lexicon::LexObjectProperty::String(
                                    ::jacquard_lexicon::lexicon::LexString {
                                        description: Some(::jacquard_common::CowStr::new_static(
                                            "Reason for revocation",
                                        )),
                                        format: None,
                                        default: None,
                                        min_length: None,
                                        max_length: Some(256usize),
                                        min_graphemes: None,
                                        max_graphemes: None,
                                        r#enum: None,
                                        r#const: None,
                                        known_values: None,
                                    },
                                ),
                            );
                            map
                        },
                    },
                ),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("main"),
                ::jacquard_lexicon::lexicon::LexUserType::Record(::jacquard_lexicon::lexicon::LexRecord {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "A single declaration chain entry. Keys are deterministic: e{epoch}-s{seq} (zero-padded to 20 digits each).",
                        ),
                    ),
                    key: Some(::jacquard_common::CowStr::new_static("any")),
                    record: ::jacquard_lexicon::lexicon::LexRecordRecord::Object(::jacquard_lexicon::lexicon::LexObject {
                        description: None,
                        required: Some(
                            vec![
                                ::jacquard_common::smol_str::SmolStr::new_static("did"),
                                ::jacquard_common::smol_str::SmolStr::new_static("epoch"),
                                ::jacquard_common::smol_str::SmolStr::new_static("seq"),
                                ::jacquard_common::smol_str::SmolStr::new_static("event"),
                                ::jacquard_common::smol_str::SmolStr::new_static("proofs"),
                                ::jacquard_common::smol_str::SmolStr::new_static("createdAt")
                            ],
                        ),
                        nullable: None,
                        properties: {
                            #[allow(unused_mut)]
                            let mut map = ::std::collections::BTreeMap::new();
                            map.insert(
                                ::jacquard_common::smol_str::SmolStr::new_static(
                                    "createdAt",
                                ),
                                ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                    description: Some(
                                        ::jacquard_common::CowStr::new_static(
                                            "When this declaration entry was created",
                                        ),
                                    ),
                                    format: Some(
                                        ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                    ),
                                    default: None,
                                    min_length: None,
                                    max_length: None,
                                    min_graphemes: None,
                                    max_graphemes: None,
                                    r#enum: None,
                                    r#const: None,
                                    known_values: None,
                                }),
                            );
                            map.insert(
                                ::jacquard_common::smol_str::SmolStr::new_static("did"),
                                ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                    description: Some(
                                        ::jacquard_common::CowStr::new_static(
                                            "DID of the account that owns this declaration chain",
                                        ),
                                    ),
                                    format: Some(
                                        ::jacquard_lexicon::lexicon::LexStringFormat::Did,
                                    ),
                                    default: None,
                                    min_length: None,
                                    max_length: None,
                                    min_graphemes: None,
                                    max_graphemes: None,
                                    r#enum: None,
                                    r#const: None,
                                    known_values: None,
                                }),
                            );
                            map.insert(
                                ::jacquard_common::smol_str::SmolStr::new_static("epoch"),
                                ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                    description: None,
                                    default: None,
                                    minimum: Some(0i64),
                                    maximum: None,
                                    r#enum: None,
                                    r#const: None,
                                }),
                            );
                            map.insert(
                                ::jacquard_common::smol_str::SmolStr::new_static("event"),
                                ::jacquard_lexicon::lexicon::LexObjectProperty::Union(::jacquard_lexicon::lexicon::LexRefUnion {
                                    description: Some(
                                        ::jacquard_common::CowStr::new_static(
                                            "The declaration event payload",
                                        ),
                                    ),
                                    refs: vec![
                                        ::jacquard_common::CowStr::new_static("#rootInit"),
                                        ::jacquard_common::CowStr::new_static("#deviceAdd"),
                                        ::jacquard_common::CowStr::new_static("#deviceRevoke"),
                                        ::jacquard_common::CowStr::new_static("#rootRotate"),
                                        ::jacquard_common::CowStr::new_static("#recoveryRotateOnlineRoot"),
                                        ::jacquard_common::CowStr::new_static("#chatPolicyUpdate")
                                    ],
                                    closed: None,
                                }),
                            );
                            map.insert(
                                ::jacquard_common::smol_str::SmolStr::new_static("prev"),
                                ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                    description: None,
                                    r#ref: ::jacquard_common::CowStr::new_static("#prevLink"),
                                }),
                            );
                            map.insert(
                                ::jacquard_common::smol_str::SmolStr::new_static("proofs"),
                                ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                    description: None,
                                    r#ref: ::jacquard_common::CowStr::new_static("#proofs"),
                                }),
                            );
                            map.insert(
                                ::jacquard_common::smol_str::SmolStr::new_static("seq"),
                                ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                    description: None,
                                    default: None,
                                    minimum: Some(0i64),
                                    maximum: None,
                                    r#enum: None,
                                    r#const: None,
                                }),
                            );
                            map
                        },
                    }),
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("prevLink"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(
                    ::jacquard_lexicon::lexicon::LexObject {
                        description: Some(::jacquard_common::CowStr::new_static(
                            "Link to the previous record in the declaration chain",
                        )),
                        required: Some(vec![::jacquard_common::smol_str::SmolStr::new_static(
                            "cid",
                        )]),
                        nullable: None,
                        properties: {
                            #[allow(unused_mut)]
                            let mut map = ::std::collections::BTreeMap::new();
                            map.insert(
                                ::jacquard_common::smol_str::SmolStr::new_static("cid"),
                                ::jacquard_lexicon::lexicon::LexObjectProperty::String(
                                    ::jacquard_lexicon::lexicon::LexString {
                                        description: Some(::jacquard_common::CowStr::new_static(
                                            "CID of the previous declaration record",
                                        )),
                                        format: None,
                                        default: None,
                                        min_length: None,
                                        max_length: None,
                                        min_graphemes: None,
                                        max_graphemes: None,
                                        r#enum: None,
                                        r#const: None,
                                        known_values: None,
                                    },
                                ),
                            );
                            map
                        },
                    },
                ),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("proofs"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(
                    ::jacquard_lexicon::lexicon::LexObject {
                        description: Some(::jacquard_common::CowStr::new_static(
                            "Cryptographic proofs authenticating this declaration entry",
                        )),
                        required: Some(vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("sig"),
                            ::jacquard_common::smol_str::SmolStr::new_static("sigAlg"),
                        ]),
                        nullable: None,
                        properties: {
                            #[allow(unused_mut)]
                            let mut map = ::std::collections::BTreeMap::new();
                            map.insert(
                                ::jacquard_common::smol_str::SmolStr::new_static("coSig"),
                                ::jacquard_lexicon::lexicon::LexObjectProperty::Bytes(
                                    ::jacquard_lexicon::lexicon::LexBytes {
                                        description: None,
                                        max_length: None,
                                        min_length: None,
                                    },
                                ),
                            );
                            map.insert(
                                ::jacquard_common::smol_str::SmolStr::new_static("coSigAlg"),
                                ::jacquard_lexicon::lexicon::LexObjectProperty::String(
                                    ::jacquard_lexicon::lexicon::LexString {
                                        description: Some(::jacquard_common::CowStr::new_static(
                                            "Algorithm of the co-signature",
                                        )),
                                        format: None,
                                        default: None,
                                        min_length: None,
                                        max_length: None,
                                        min_graphemes: None,
                                        max_graphemes: None,
                                        r#enum: None,
                                        r#const: None,
                                        known_values: None,
                                    },
                                ),
                            );
                            map.insert(
                                ::jacquard_common::smol_str::SmolStr::new_static("deviceProof"),
                                ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(
                                    ::jacquard_lexicon::lexicon::LexRef {
                                        description: None,
                                        r#ref: ::jacquard_common::CowStr::new_static(
                                            "#deviceProof",
                                        ),
                                    },
                                ),
                            );
                            map.insert(
                                ::jacquard_common::smol_str::SmolStr::new_static("sig"),
                                ::jacquard_lexicon::lexicon::LexObjectProperty::Bytes(
                                    ::jacquard_lexicon::lexicon::LexBytes {
                                        description: None,
                                        max_length: None,
                                        min_length: None,
                                    },
                                ),
                            );
                            map.insert(
                                ::jacquard_common::smol_str::SmolStr::new_static("sigAlg"),
                                ::jacquard_lexicon::lexicon::LexObjectProperty::String(
                                    ::jacquard_lexicon::lexicon::LexString {
                                        description: Some(::jacquard_common::CowStr::new_static(
                                            "Algorithm used for the signature (e.g., 'p256')",
                                        )),
                                        format: None,
                                        default: None,
                                        min_length: None,
                                        max_length: None,
                                        min_graphemes: None,
                                        max_graphemes: None,
                                        r#enum: None,
                                        r#const: None,
                                        known_values: None,
                                    },
                                ),
                            );
                            map
                        },
                    },
                ),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("recoveryRotateOnlineRoot"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(
                    ::jacquard_lexicon::lexicon::LexObject {
                        description: Some(::jacquard_common::CowStr::new_static(
                            "Emergency rotation of the online root key using the recovery root",
                        )),
                        required: Some(vec![
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "newOnlineRootPublicKey",
                            ),
                            ::jacquard_common::smol_str::SmolStr::new_static("newOnlineRootAlg"),
                        ]),
                        nullable: None,
                        properties: {
                            #[allow(unused_mut)]
                            let mut map = ::std::collections::BTreeMap::new();
                            map.insert(
                                ::jacquard_common::smol_str::SmolStr::new_static(
                                    "newOnlineRootAlg",
                                ),
                                ::jacquard_lexicon::lexicon::LexObjectProperty::String(
                                    ::jacquard_lexicon::lexicon::LexString {
                                        description: Some(::jacquard_common::CowStr::new_static(
                                            "Algorithm of the new online root key",
                                        )),
                                        format: None,
                                        default: None,
                                        min_length: None,
                                        max_length: None,
                                        min_graphemes: None,
                                        max_graphemes: None,
                                        r#enum: None,
                                        r#const: None,
                                        known_values: None,
                                    },
                                ),
                            );
                            map.insert(
                                ::jacquard_common::smol_str::SmolStr::new_static(
                                    "newOnlineRootPublicKey",
                                ),
                                ::jacquard_lexicon::lexicon::LexObjectProperty::Bytes(
                                    ::jacquard_lexicon::lexicon::LexBytes {
                                        description: None,
                                        max_length: None,
                                        min_length: None,
                                    },
                                ),
                            );
                            map.insert(
                                ::jacquard_common::smol_str::SmolStr::new_static("recoveryReason"),
                                ::jacquard_lexicon::lexicon::LexObjectProperty::String(
                                    ::jacquard_lexicon::lexicon::LexString {
                                        description: Some(::jacquard_common::CowStr::new_static(
                                            "Reason for recovery rotation",
                                        )),
                                        format: None,
                                        default: None,
                                        min_length: None,
                                        max_length: Some(256usize),
                                        min_graphemes: None,
                                        max_graphemes: None,
                                        r#enum: None,
                                        r#const: None,
                                        known_values: None,
                                    },
                                ),
                            );
                            map
                        },
                    },
                ),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("rootInit"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Initialize the declaration chain with root keys. Must be seq=0.",
                        ),
                    ),
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("onlineRootPublicKey"),
                            ::jacquard_common::smol_str::SmolStr::new_static("onlineRootAlg"),
                            ::jacquard_common::smol_str::SmolStr::new_static("recoveryRootPublicKey"),
                            ::jacquard_common::smol_str::SmolStr::new_static("recoveryRootAlg")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::std::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("note"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Optional human-readable note (e.g., 'catbird-initialize')",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: Some(256usize),
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "onlineRootAlg",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Algorithm of the online root key (e.g., 'p256')",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "onlineRootPublicKey",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Bytes(::jacquard_lexicon::lexicon::LexBytes {
                                description: None,
                                max_length: None,
                                min_length: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "recoveryRootAlg",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Algorithm of the recovery root key (e.g., 'p256')",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "recoveryRootPublicKey",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Bytes(::jacquard_lexicon::lexicon::LexBytes {
                                description: None,
                                max_length: None,
                                min_length: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("rootRotate"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(
                    ::jacquard_lexicon::lexicon::LexObject {
                        description: Some(::jacquard_common::CowStr::new_static(
                            "Rotate the online root key (signed by the old online root)",
                        )),
                        required: Some(vec![
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "newOnlineRootPublicKey",
                            ),
                            ::jacquard_common::smol_str::SmolStr::new_static("newOnlineRootAlg"),
                        ]),
                        nullable: None,
                        properties: {
                            #[allow(unused_mut)]
                            let mut map = ::std::collections::BTreeMap::new();
                            map.insert(
                                ::jacquard_common::smol_str::SmolStr::new_static(
                                    "newOnlineRootAlg",
                                ),
                                ::jacquard_lexicon::lexicon::LexObjectProperty::String(
                                    ::jacquard_lexicon::lexicon::LexString {
                                        description: Some(::jacquard_common::CowStr::new_static(
                                            "Algorithm of the new online root key",
                                        )),
                                        format: None,
                                        default: None,
                                        min_length: None,
                                        max_length: None,
                                        min_graphemes: None,
                                        max_graphemes: None,
                                        r#enum: None,
                                        r#const: None,
                                        known_values: None,
                                    },
                                ),
                            );
                            map.insert(
                                ::jacquard_common::smol_str::SmolStr::new_static(
                                    "newOnlineRootPublicKey",
                                ),
                                ::jacquard_lexicon::lexicon::LexObjectProperty::Bytes(
                                    ::jacquard_lexicon::lexicon::LexBytes {
                                        description: None,
                                        max_length: None,
                                        min_length: None,
                                    },
                                ),
                            );
                            map.insert(
                                ::jacquard_common::smol_str::SmolStr::new_static("rotationMode"),
                                ::jacquard_lexicon::lexicon::LexObjectProperty::String(
                                    ::jacquard_lexicon::lexicon::LexString {
                                        description: Some(::jacquard_common::CowStr::new_static(
                                            "Rotation mode (e.g., 'normal', 'emergency')",
                                        )),
                                        format: None,
                                        default: None,
                                        min_length: None,
                                        max_length: None,
                                        min_graphemes: None,
                                        max_graphemes: None,
                                        r#enum: None,
                                        r#const: None,
                                        known_values: None,
                                    },
                                ),
                            );
                            map
                        },
                    },
                ),
            );
            map
        },
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for ChatPolicyUpdate<'a> {
    fn nsid() -> &'static str {
        "blue.catbird.mlsChat.declaration"
    }
    fn def_name() -> &'static str {
        "chatPolicyUpdate"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_blue_catbird_mlsChat_declaration()
    }
    fn validate(
        &self,
    ) -> ::std::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        if let Some(ref value) = self.auto_expire_days {
            if *value < 0i64 {
                return Err(::jacquard_lexicon::validation::ConstraintError::Minimum {
                    path: ::jacquard_lexicon::validation::ValidationPath::from_field(
                        "auto_expire_days",
                    ),
                    min: 0i64,
                    actual: *value,
                });
            }
        }
        Ok(())
    }
}

/// Add a device to the authorized set
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq, jacquard_derive::IntoStatic,
)]
#[serde(rename_all = "camelCase")]
pub struct DeviceAdd<'a> {
    /// Device UUID identifier
    #[serde(borrow)]
    pub device_id: jacquard_common::CowStr<'a>,
    /// The device's MLS signature public key
    #[serde(with = "jacquard_common::serde_bytes_helper")]
    pub device_mls_signature_public_key: bytes::Bytes,
    /// Human-readable device name
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub device_name: std::option::Option<jacquard_common::CowStr<'a>>,
}

pub mod device_add_state {

    pub use crate::builder_types::{IsSet, IsUnset, Set, Unset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type DeviceId;
        type DeviceMlsSignaturePublicKey;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type DeviceId = Unset;
        type DeviceMlsSignaturePublicKey = Unset;
    }
    ///State transition - sets the `device_id` field to Set
    pub struct SetDeviceId<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetDeviceId<S> {}
    impl<S: State> State for SetDeviceId<S> {
        type DeviceId = Set<members::device_id>;
        type DeviceMlsSignaturePublicKey = S::DeviceMlsSignaturePublicKey;
    }
    ///State transition - sets the `device_mls_signature_public_key` field to Set
    pub struct SetDeviceMlsSignaturePublicKey<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetDeviceMlsSignaturePublicKey<S> {}
    impl<S: State> State for SetDeviceMlsSignaturePublicKey<S> {
        type DeviceId = S::DeviceId;
        type DeviceMlsSignaturePublicKey = Set<members::device_mls_signature_public_key>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `device_id` field
        pub struct device_id(());
        ///Marker type for the `device_mls_signature_public_key` field
        pub struct device_mls_signature_public_key(());
    }
}

/// Builder for constructing an instance of this type
pub struct DeviceAddBuilder<'a, S: device_add_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<bytes::Bytes>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> DeviceAdd<'a> {
    /// Create a new builder for this type
    pub fn new() -> DeviceAddBuilder<'a, device_add_state::Empty> {
        DeviceAddBuilder::new()
    }
}

impl<'a> DeviceAddBuilder<'a, device_add_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        DeviceAddBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> DeviceAddBuilder<'a, S>
where
    S: device_add_state::State,
    S::DeviceId: device_add_state::IsUnset,
{
    /// Set the `deviceId` field (required)
    pub fn device_id(
        mut self,
        value: impl Into<jacquard_common::CowStr<'a>>,
    ) -> DeviceAddBuilder<'a, device_add_state::SetDeviceId<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        DeviceAddBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> DeviceAddBuilder<'a, S>
where
    S: device_add_state::State,
    S::DeviceMlsSignaturePublicKey: device_add_state::IsUnset,
{
    /// Set the `deviceMlsSignaturePublicKey` field (required)
    pub fn device_mls_signature_public_key(
        mut self,
        value: impl Into<bytes::Bytes>,
    ) -> DeviceAddBuilder<'a, device_add_state::SetDeviceMlsSignaturePublicKey<S>> {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        DeviceAddBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: device_add_state::State> DeviceAddBuilder<'a, S> {
    /// Set the `deviceName` field (optional)
    pub fn device_name(mut self, value: impl Into<Option<jacquard_common::CowStr<'a>>>) -> Self {
        self.__unsafe_private_named.2 = value.into();
        self
    }
    /// Set the `deviceName` field to an Option value (optional)
    pub fn maybe_device_name(mut self, value: Option<jacquard_common::CowStr<'a>>) -> Self {
        self.__unsafe_private_named.2 = value;
        self
    }
}

impl<'a, S> DeviceAddBuilder<'a, S>
where
    S: device_add_state::State,
    S::DeviceId: device_add_state::IsSet,
    S::DeviceMlsSignaturePublicKey: device_add_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> DeviceAdd<'a> {
        DeviceAdd {
            device_id: self.__unsafe_private_named.0.unwrap(),
            device_mls_signature_public_key: self.__unsafe_private_named.1.unwrap(),
            device_name: self.__unsafe_private_named.2,
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> DeviceAdd<'a> {
        DeviceAdd {
            device_id: self.__unsafe_private_named.0.unwrap(),
            device_mls_signature_public_key: self.__unsafe_private_named.1.unwrap(),
            device_name: self.__unsafe_private_named.2,
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for DeviceAdd<'a> {
    fn nsid() -> &'static str {
        "blue.catbird.mlsChat.declaration"
    }
    fn def_name() -> &'static str {
        "deviceAdd"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_blue_catbird_mlsChat_declaration()
    }
    fn validate(
        &self,
    ) -> ::std::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        if let Some(ref value) = self.device_name {
            #[allow(unused_comparisons)]
            if <str>::len(value.as_ref()) > 128usize {
                return Err(::jacquard_lexicon::validation::ConstraintError::MaxLength {
                    path: ::jacquard_lexicon::validation::ValidationPath::from_field("device_name"),
                    max: 128usize,
                    actual: <str>::len(value.as_ref()),
                });
            }
        }
        Ok(())
    }
}

/// Proof from the device being added, demonstrating possession of the device key
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq, jacquard_derive::IntoStatic,
)]
#[serde(rename_all = "camelCase")]
pub struct DeviceProof<'a> {
    /// Algorithm of the device proof signature
    #[serde(borrow)]
    pub proof_alg: jacquard_common::CowStr<'a>,
    /// Signature by the device's MLS signature key
    #[serde(with = "jacquard_common::serde_bytes_helper")]
    pub proof_sig: bytes::Bytes,
}

pub mod device_proof_state {

    pub use crate::builder_types::{IsSet, IsUnset, Set, Unset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type ProofSig;
        type ProofAlg;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type ProofSig = Unset;
        type ProofAlg = Unset;
    }
    ///State transition - sets the `proof_sig` field to Set
    pub struct SetProofSig<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetProofSig<S> {}
    impl<S: State> State for SetProofSig<S> {
        type ProofSig = Set<members::proof_sig>;
        type ProofAlg = S::ProofAlg;
    }
    ///State transition - sets the `proof_alg` field to Set
    pub struct SetProofAlg<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetProofAlg<S> {}
    impl<S: State> State for SetProofAlg<S> {
        type ProofSig = S::ProofSig;
        type ProofAlg = Set<members::proof_alg>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `proof_sig` field
        pub struct proof_sig(());
        ///Marker type for the `proof_alg` field
        pub struct proof_alg(());
    }
}

/// Builder for constructing an instance of this type
pub struct DeviceProofBuilder<'a, S: device_proof_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<bytes::Bytes>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> DeviceProof<'a> {
    /// Create a new builder for this type
    pub fn new() -> DeviceProofBuilder<'a, device_proof_state::Empty> {
        DeviceProofBuilder::new()
    }
}

impl<'a> DeviceProofBuilder<'a, device_proof_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        DeviceProofBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> DeviceProofBuilder<'a, S>
where
    S: device_proof_state::State,
    S::ProofAlg: device_proof_state::IsUnset,
{
    /// Set the `proofAlg` field (required)
    pub fn proof_alg(
        mut self,
        value: impl Into<jacquard_common::CowStr<'a>>,
    ) -> DeviceProofBuilder<'a, device_proof_state::SetProofAlg<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        DeviceProofBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> DeviceProofBuilder<'a, S>
where
    S: device_proof_state::State,
    S::ProofSig: device_proof_state::IsUnset,
{
    /// Set the `proofSig` field (required)
    pub fn proof_sig(
        mut self,
        value: impl Into<bytes::Bytes>,
    ) -> DeviceProofBuilder<'a, device_proof_state::SetProofSig<S>> {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        DeviceProofBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> DeviceProofBuilder<'a, S>
where
    S: device_proof_state::State,
    S::ProofSig: device_proof_state::IsSet,
    S::ProofAlg: device_proof_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> DeviceProof<'a> {
        DeviceProof {
            proof_alg: self.__unsafe_private_named.0.unwrap(),
            proof_sig: self.__unsafe_private_named.1.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> DeviceProof<'a> {
        DeviceProof {
            proof_alg: self.__unsafe_private_named.0.unwrap(),
            proof_sig: self.__unsafe_private_named.1.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for DeviceProof<'a> {
    fn nsid() -> &'static str {
        "blue.catbird.mlsChat.declaration"
    }
    fn def_name() -> &'static str {
        "deviceProof"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_blue_catbird_mlsChat_declaration()
    }
    fn validate(
        &self,
    ) -> ::std::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Revoke a device from the authorized set
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    Default,
)]
#[serde(rename_all = "camelCase")]
pub struct DeviceRevoke<'a> {
    /// The revoked device's UUID
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub device_id: std::option::Option<jacquard_common::CowStr<'a>>,
    /// The revoked device's MLS signature public key
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(default, with = "jacquard_common::opt_serde_bytes_helper")]
    pub device_mls_signature_public_key: std::option::Option<bytes::Bytes>,
    /// Reason for revocation
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub reason: std::option::Option<jacquard_common::CowStr<'a>>,
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for DeviceRevoke<'a> {
    fn nsid() -> &'static str {
        "blue.catbird.mlsChat.declaration"
    }
    fn def_name() -> &'static str {
        "deviceRevoke"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_blue_catbird_mlsChat_declaration()
    }
    fn validate(
        &self,
    ) -> ::std::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        if let Some(ref value) = self.reason {
            #[allow(unused_comparisons)]
            if <str>::len(value.as_ref()) > 256usize {
                return Err(::jacquard_lexicon::validation::ConstraintError::MaxLength {
                    path: ::jacquard_lexicon::validation::ValidationPath::from_field("reason"),
                    max: 256usize,
                    actual: <str>::len(value.as_ref()),
                });
            }
        }
        Ok(())
    }
}

/// A single declaration chain entry. Keys are deterministic: e{epoch}-s{seq} (zero-padded to 20 digits each).
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq, jacquard_derive::IntoStatic,
)]
#[serde(rename_all = "camelCase")]
pub struct Declaration<'a> {
    /// When this declaration entry was created
    pub created_at: jacquard_common::types::string::Datetime,
    /// DID of the account that owns this declaration chain
    #[serde(borrow)]
    pub did: jacquard_common::types::string::Did<'a>,
    /// Declaration epoch  incremented on root key rotation
    pub epoch: i64,
    /// The declaration event payload
    #[serde(borrow)]
    pub event: DeclarationEvent<'a>,
    /// Link to the previous declaration record (null for rootInit at seq=0)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub prev:
        std::option::Option<crate::generated::blue_catbird::mlsChat::declaration::PrevLink<'a>>,
    /// Cryptographic proofs for this declaration entry
    #[serde(borrow)]
    pub proofs: crate::generated::blue_catbird::mlsChat::declaration::Proofs<'a>,
    /// Sequence number within the epoch, starting at 0 for rootInit
    pub seq: i64,
}

pub mod declaration_state {

    pub use crate::builder_types::{IsSet, IsUnset, Set, Unset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Proofs;
        type Seq;
        type Epoch;
        type Event;
        type CreatedAt;
        type Did;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Proofs = Unset;
        type Seq = Unset;
        type Epoch = Unset;
        type Event = Unset;
        type CreatedAt = Unset;
        type Did = Unset;
    }
    ///State transition - sets the `proofs` field to Set
    pub struct SetProofs<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetProofs<S> {}
    impl<S: State> State for SetProofs<S> {
        type Proofs = Set<members::proofs>;
        type Seq = S::Seq;
        type Epoch = S::Epoch;
        type Event = S::Event;
        type CreatedAt = S::CreatedAt;
        type Did = S::Did;
    }
    ///State transition - sets the `seq` field to Set
    pub struct SetSeq<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetSeq<S> {}
    impl<S: State> State for SetSeq<S> {
        type Proofs = S::Proofs;
        type Seq = Set<members::seq>;
        type Epoch = S::Epoch;
        type Event = S::Event;
        type CreatedAt = S::CreatedAt;
        type Did = S::Did;
    }
    ///State transition - sets the `epoch` field to Set
    pub struct SetEpoch<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetEpoch<S> {}
    impl<S: State> State for SetEpoch<S> {
        type Proofs = S::Proofs;
        type Seq = S::Seq;
        type Epoch = Set<members::epoch>;
        type Event = S::Event;
        type CreatedAt = S::CreatedAt;
        type Did = S::Did;
    }
    ///State transition - sets the `event` field to Set
    pub struct SetEvent<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetEvent<S> {}
    impl<S: State> State for SetEvent<S> {
        type Proofs = S::Proofs;
        type Seq = S::Seq;
        type Epoch = S::Epoch;
        type Event = Set<members::event>;
        type CreatedAt = S::CreatedAt;
        type Did = S::Did;
    }
    ///State transition - sets the `created_at` field to Set
    pub struct SetCreatedAt<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetCreatedAt<S> {}
    impl<S: State> State for SetCreatedAt<S> {
        type Proofs = S::Proofs;
        type Seq = S::Seq;
        type Epoch = S::Epoch;
        type Event = S::Event;
        type CreatedAt = Set<members::created_at>;
        type Did = S::Did;
    }
    ///State transition - sets the `did` field to Set
    pub struct SetDid<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetDid<S> {}
    impl<S: State> State for SetDid<S> {
        type Proofs = S::Proofs;
        type Seq = S::Seq;
        type Epoch = S::Epoch;
        type Event = S::Event;
        type CreatedAt = S::CreatedAt;
        type Did = Set<members::did>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `proofs` field
        pub struct proofs(());
        ///Marker type for the `seq` field
        pub struct seq(());
        ///Marker type for the `epoch` field
        pub struct epoch(());
        ///Marker type for the `event` field
        pub struct event(());
        ///Marker type for the `created_at` field
        pub struct created_at(());
        ///Marker type for the `did` field
        pub struct did(());
    }
}

/// Builder for constructing an instance of this type
pub struct DeclarationBuilder<'a, S: declaration_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<jacquard_common::types::string::Datetime>,
        ::core::option::Option<jacquard_common::types::string::Did<'a>>,
        ::core::option::Option<i64>,
        ::core::option::Option<DeclarationEvent<'a>>,
        ::core::option::Option<crate::generated::blue_catbird::mlsChat::declaration::PrevLink<'a>>,
        ::core::option::Option<crate::generated::blue_catbird::mlsChat::declaration::Proofs<'a>>,
        ::core::option::Option<i64>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> Declaration<'a> {
    /// Create a new builder for this type
    pub fn new() -> DeclarationBuilder<'a, declaration_state::Empty> {
        DeclarationBuilder::new()
    }
}

impl<'a> DeclarationBuilder<'a, declaration_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        DeclarationBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None, None, None, None, None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> DeclarationBuilder<'a, S>
where
    S: declaration_state::State,
    S::CreatedAt: declaration_state::IsUnset,
{
    /// Set the `createdAt` field (required)
    pub fn created_at(
        mut self,
        value: impl Into<jacquard_common::types::string::Datetime>,
    ) -> DeclarationBuilder<'a, declaration_state::SetCreatedAt<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        DeclarationBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> DeclarationBuilder<'a, S>
where
    S: declaration_state::State,
    S::Did: declaration_state::IsUnset,
{
    /// Set the `did` field (required)
    pub fn did(
        mut self,
        value: impl Into<jacquard_common::types::string::Did<'a>>,
    ) -> DeclarationBuilder<'a, declaration_state::SetDid<S>> {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        DeclarationBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> DeclarationBuilder<'a, S>
where
    S: declaration_state::State,
    S::Epoch: declaration_state::IsUnset,
{
    /// Set the `epoch` field (required)
    pub fn epoch(
        mut self,
        value: impl Into<i64>,
    ) -> DeclarationBuilder<'a, declaration_state::SetEpoch<S>> {
        self.__unsafe_private_named.2 = ::core::option::Option::Some(value.into());
        DeclarationBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> DeclarationBuilder<'a, S>
where
    S: declaration_state::State,
    S::Event: declaration_state::IsUnset,
{
    /// Set the `event` field (required)
    pub fn event(
        mut self,
        value: impl Into<DeclarationEvent<'a>>,
    ) -> DeclarationBuilder<'a, declaration_state::SetEvent<S>> {
        self.__unsafe_private_named.3 = ::core::option::Option::Some(value.into());
        DeclarationBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: declaration_state::State> DeclarationBuilder<'a, S> {
    /// Set the `prev` field (optional)
    pub fn prev(
        mut self,
        value: impl Into<Option<crate::generated::blue_catbird::mlsChat::declaration::PrevLink<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.4 = value.into();
        self
    }
    /// Set the `prev` field to an Option value (optional)
    pub fn maybe_prev(
        mut self,
        value: Option<crate::generated::blue_catbird::mlsChat::declaration::PrevLink<'a>>,
    ) -> Self {
        self.__unsafe_private_named.4 = value;
        self
    }
}

impl<'a, S> DeclarationBuilder<'a, S>
where
    S: declaration_state::State,
    S::Proofs: declaration_state::IsUnset,
{
    /// Set the `proofs` field (required)
    pub fn proofs(
        mut self,
        value: impl Into<crate::generated::blue_catbird::mlsChat::declaration::Proofs<'a>>,
    ) -> DeclarationBuilder<'a, declaration_state::SetProofs<S>> {
        self.__unsafe_private_named.5 = ::core::option::Option::Some(value.into());
        DeclarationBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> DeclarationBuilder<'a, S>
where
    S: declaration_state::State,
    S::Seq: declaration_state::IsUnset,
{
    /// Set the `seq` field (required)
    pub fn seq(
        mut self,
        value: impl Into<i64>,
    ) -> DeclarationBuilder<'a, declaration_state::SetSeq<S>> {
        self.__unsafe_private_named.6 = ::core::option::Option::Some(value.into());
        DeclarationBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> DeclarationBuilder<'a, S>
where
    S: declaration_state::State,
    S::Proofs: declaration_state::IsSet,
    S::Seq: declaration_state::IsSet,
    S::Epoch: declaration_state::IsSet,
    S::Event: declaration_state::IsSet,
    S::CreatedAt: declaration_state::IsSet,
    S::Did: declaration_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> Declaration<'a> {
        Declaration {
            created_at: self.__unsafe_private_named.0.unwrap(),
            did: self.__unsafe_private_named.1.unwrap(),
            epoch: self.__unsafe_private_named.2.unwrap(),
            event: self.__unsafe_private_named.3.unwrap(),
            prev: self.__unsafe_private_named.4,
            proofs: self.__unsafe_private_named.5.unwrap(),
            seq: self.__unsafe_private_named.6.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> Declaration<'a> {
        Declaration {
            created_at: self.__unsafe_private_named.0.unwrap(),
            did: self.__unsafe_private_named.1.unwrap(),
            epoch: self.__unsafe_private_named.2.unwrap(),
            event: self.__unsafe_private_named.3.unwrap(),
            prev: self.__unsafe_private_named.4,
            proofs: self.__unsafe_private_named.5.unwrap(),
            seq: self.__unsafe_private_named.6.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> Declaration<'a> {
    pub fn uri(
        uri: impl Into<jacquard_common::CowStr<'a>>,
    ) -> Result<
        jacquard_common::types::uri::RecordUri<'a, DeclarationRecord>,
        jacquard_common::types::uri::UriError,
    > {
        jacquard_common::types::uri::RecordUri::try_from_uri(
            jacquard_common::types::string::AtUri::new_cow(uri.into())?,
        )
    }
}

#[jacquard_derive::open_union]
#[derive(
    serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq, jacquard_derive::IntoStatic,
)]
#[serde(tag = "$type")]
#[serde(bound(deserialize = "'de: 'a"))]
pub enum DeclarationEvent<'a> {
    #[serde(rename = "blue.catbird.mlsChat.declaration#rootInit")]
    RootInit(Box<crate::generated::blue_catbird::mlsChat::declaration::RootInit<'a>>),
    #[serde(rename = "blue.catbird.mlsChat.declaration#deviceAdd")]
    DeviceAdd(Box<crate::generated::blue_catbird::mlsChat::declaration::DeviceAdd<'a>>),
    #[serde(rename = "blue.catbird.mlsChat.declaration#deviceRevoke")]
    DeviceRevoke(Box<crate::generated::blue_catbird::mlsChat::declaration::DeviceRevoke<'a>>),
    #[serde(rename = "blue.catbird.mlsChat.declaration#rootRotate")]
    RootRotate(Box<crate::generated::blue_catbird::mlsChat::declaration::RootRotate<'a>>),
    #[serde(rename = "blue.catbird.mlsChat.declaration#recoveryRotateOnlineRoot")]
    RecoveryRotateOnlineRoot(
        Box<crate::generated::blue_catbird::mlsChat::declaration::RecoveryRotateOnlineRoot<'a>>,
    ),
    #[serde(rename = "blue.catbird.mlsChat.declaration#chatPolicyUpdate")]
    ChatPolicyUpdate(
        Box<crate::generated::blue_catbird::mlsChat::declaration::ChatPolicyUpdate<'a>>,
    ),
}

/// Typed wrapper for GetRecord response with this collection's record type.
#[derive(
    serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq, jacquard_derive::IntoStatic,
)]
#[serde(rename_all = "camelCase")]
pub struct DeclarationGetRecordOutput<'a> {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub cid: std::option::Option<jacquard_common::types::string::Cid<'a>>,
    #[serde(borrow)]
    pub uri: jacquard_common::types::string::AtUri<'a>,
    #[serde(borrow)]
    pub value: Declaration<'a>,
}

impl From<DeclarationGetRecordOutput<'_>> for Declaration<'_> {
    fn from(output: DeclarationGetRecordOutput<'_>) -> Self {
        use jacquard_common::IntoStatic;
        output.value.into_static()
    }
}

impl jacquard_common::types::collection::Collection for Declaration<'_> {
    const NSID: &'static str = "blue.catbird.mlsChat.declaration";
    type Record = DeclarationRecord;
}

/// Marker type for deserializing records from this collection.
#[derive(Debug, serde::Serialize, serde::Deserialize)]
pub struct DeclarationRecord;
impl jacquard_common::xrpc::XrpcResp for DeclarationRecord {
    const NSID: &'static str = "blue.catbird.mlsChat.declaration";
    const ENCODING: &'static str = "application/json";
    type Output<'de> = DeclarationGetRecordOutput<'de>;
    type Err<'de> = jacquard_common::types::collection::RecordError<'de>;
}

impl jacquard_common::types::collection::Collection for DeclarationRecord {
    const NSID: &'static str = "blue.catbird.mlsChat.declaration";
    type Record = DeclarationRecord;
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for Declaration<'a> {
    fn nsid() -> &'static str {
        "blue.catbird.mlsChat.declaration"
    }
    fn def_name() -> &'static str {
        "main"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_blue_catbird_mlsChat_declaration()
    }
    fn validate(
        &self,
    ) -> ::std::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        {
            let value = &self.epoch;
            if *value < 0i64 {
                return Err(::jacquard_lexicon::validation::ConstraintError::Minimum {
                    path: ::jacquard_lexicon::validation::ValidationPath::from_field("epoch"),
                    min: 0i64,
                    actual: *value,
                });
            }
        }
        {
            let value = &self.seq;
            if *value < 0i64 {
                return Err(::jacquard_lexicon::validation::ConstraintError::Minimum {
                    path: ::jacquard_lexicon::validation::ValidationPath::from_field("seq"),
                    min: 0i64,
                    actual: *value,
                });
            }
        }
        Ok(())
    }
}

/// Link to the previous record in the declaration chain
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    Default,
)]
#[serde(rename_all = "camelCase")]
pub struct PrevLink<'a> {
    /// CID of the previous declaration record
    #[serde(borrow)]
    pub cid: jacquard_common::CowStr<'a>,
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for PrevLink<'a> {
    fn nsid() -> &'static str {
        "blue.catbird.mlsChat.declaration"
    }
    fn def_name() -> &'static str {
        "prevLink"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_blue_catbird_mlsChat_declaration()
    }
    fn validate(
        &self,
    ) -> ::std::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Cryptographic proofs authenticating this declaration entry
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq, jacquard_derive::IntoStatic,
)]
#[serde(rename_all = "camelCase")]
pub struct Proofs<'a> {
    /// Optional co-signature (e.g., from the old key during rotation)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(default, with = "jacquard_common::opt_serde_bytes_helper")]
    pub co_sig: std::option::Option<bytes::Bytes>,
    /// Algorithm of the co-signature
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub co_sig_alg: std::option::Option<jacquard_common::CowStr<'a>>,
    /// Optional device-level proof (for deviceAdd events)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub device_proof:
        std::option::Option<crate::generated::blue_catbird::mlsChat::declaration::DeviceProof<'a>>,
    /// Signature over the canonical signing payload by the online (or recovery) root key
    #[serde(with = "jacquard_common::serde_bytes_helper")]
    pub sig: bytes::Bytes,
    /// Algorithm used for the signature (e.g., 'p256')
    #[serde(borrow)]
    pub sig_alg: jacquard_common::CowStr<'a>,
}

pub mod proofs_state {

    pub use crate::builder_types::{IsSet, IsUnset, Set, Unset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Sig;
        type SigAlg;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Sig = Unset;
        type SigAlg = Unset;
    }
    ///State transition - sets the `sig` field to Set
    pub struct SetSig<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetSig<S> {}
    impl<S: State> State for SetSig<S> {
        type Sig = Set<members::sig>;
        type SigAlg = S::SigAlg;
    }
    ///State transition - sets the `sig_alg` field to Set
    pub struct SetSigAlg<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetSigAlg<S> {}
    impl<S: State> State for SetSigAlg<S> {
        type Sig = S::Sig;
        type SigAlg = Set<members::sig_alg>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `sig` field
        pub struct sig(());
        ///Marker type for the `sig_alg` field
        pub struct sig_alg(());
    }
}

/// Builder for constructing an instance of this type
pub struct ProofsBuilder<'a, S: proofs_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<bytes::Bytes>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<
            crate::generated::blue_catbird::mlsChat::declaration::DeviceProof<'a>,
        >,
        ::core::option::Option<bytes::Bytes>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> Proofs<'a> {
    /// Create a new builder for this type
    pub fn new() -> ProofsBuilder<'a, proofs_state::Empty> {
        ProofsBuilder::new()
    }
}

impl<'a> ProofsBuilder<'a, proofs_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        ProofsBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None, None, None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: proofs_state::State> ProofsBuilder<'a, S> {
    /// Set the `coSig` field (optional)
    pub fn co_sig(mut self, value: impl Into<Option<bytes::Bytes>>) -> Self {
        self.__unsafe_private_named.0 = value.into();
        self
    }
    /// Set the `coSig` field to an Option value (optional)
    pub fn maybe_co_sig(mut self, value: Option<bytes::Bytes>) -> Self {
        self.__unsafe_private_named.0 = value;
        self
    }
}

impl<'a, S: proofs_state::State> ProofsBuilder<'a, S> {
    /// Set the `coSigAlg` field (optional)
    pub fn co_sig_alg(mut self, value: impl Into<Option<jacquard_common::CowStr<'a>>>) -> Self {
        self.__unsafe_private_named.1 = value.into();
        self
    }
    /// Set the `coSigAlg` field to an Option value (optional)
    pub fn maybe_co_sig_alg(mut self, value: Option<jacquard_common::CowStr<'a>>) -> Self {
        self.__unsafe_private_named.1 = value;
        self
    }
}

impl<'a, S: proofs_state::State> ProofsBuilder<'a, S> {
    /// Set the `deviceProof` field (optional)
    pub fn device_proof(
        mut self,
        value: impl Into<Option<crate::generated::blue_catbird::mlsChat::declaration::DeviceProof<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.2 = value.into();
        self
    }
    /// Set the `deviceProof` field to an Option value (optional)
    pub fn maybe_device_proof(
        mut self,
        value: Option<crate::generated::blue_catbird::mlsChat::declaration::DeviceProof<'a>>,
    ) -> Self {
        self.__unsafe_private_named.2 = value;
        self
    }
}

impl<'a, S> ProofsBuilder<'a, S>
where
    S: proofs_state::State,
    S::Sig: proofs_state::IsUnset,
{
    /// Set the `sig` field (required)
    pub fn sig(
        mut self,
        value: impl Into<bytes::Bytes>,
    ) -> ProofsBuilder<'a, proofs_state::SetSig<S>> {
        self.__unsafe_private_named.3 = ::core::option::Option::Some(value.into());
        ProofsBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ProofsBuilder<'a, S>
where
    S: proofs_state::State,
    S::SigAlg: proofs_state::IsUnset,
{
    /// Set the `sigAlg` field (required)
    pub fn sig_alg(
        mut self,
        value: impl Into<jacquard_common::CowStr<'a>>,
    ) -> ProofsBuilder<'a, proofs_state::SetSigAlg<S>> {
        self.__unsafe_private_named.4 = ::core::option::Option::Some(value.into());
        ProofsBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ProofsBuilder<'a, S>
where
    S: proofs_state::State,
    S::Sig: proofs_state::IsSet,
    S::SigAlg: proofs_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> Proofs<'a> {
        Proofs {
            co_sig: self.__unsafe_private_named.0,
            co_sig_alg: self.__unsafe_private_named.1,
            device_proof: self.__unsafe_private_named.2,
            sig: self.__unsafe_private_named.3.unwrap(),
            sig_alg: self.__unsafe_private_named.4.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> Proofs<'a> {
        Proofs {
            co_sig: self.__unsafe_private_named.0,
            co_sig_alg: self.__unsafe_private_named.1,
            device_proof: self.__unsafe_private_named.2,
            sig: self.__unsafe_private_named.3.unwrap(),
            sig_alg: self.__unsafe_private_named.4.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for Proofs<'a> {
    fn nsid() -> &'static str {
        "blue.catbird.mlsChat.declaration"
    }
    fn def_name() -> &'static str {
        "proofs"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_blue_catbird_mlsChat_declaration()
    }
    fn validate(
        &self,
    ) -> ::std::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}

/// Emergency rotation of the online root key using the recovery root
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq, jacquard_derive::IntoStatic,
)]
#[serde(rename_all = "camelCase")]
pub struct RecoveryRotateOnlineRoot<'a> {
    /// Algorithm of the new online root key
    #[serde(borrow)]
    pub new_online_root_alg: jacquard_common::CowStr<'a>,
    /// New online root public key
    #[serde(with = "jacquard_common::serde_bytes_helper")]
    pub new_online_root_public_key: bytes::Bytes,
    /// Reason for recovery rotation
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub recovery_reason: std::option::Option<jacquard_common::CowStr<'a>>,
}

pub mod recovery_rotate_online_root_state {

    pub use crate::builder_types::{IsSet, IsUnset, Set, Unset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type NewOnlineRootAlg;
        type NewOnlineRootPublicKey;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type NewOnlineRootAlg = Unset;
        type NewOnlineRootPublicKey = Unset;
    }
    ///State transition - sets the `new_online_root_alg` field to Set
    pub struct SetNewOnlineRootAlg<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetNewOnlineRootAlg<S> {}
    impl<S: State> State for SetNewOnlineRootAlg<S> {
        type NewOnlineRootAlg = Set<members::new_online_root_alg>;
        type NewOnlineRootPublicKey = S::NewOnlineRootPublicKey;
    }
    ///State transition - sets the `new_online_root_public_key` field to Set
    pub struct SetNewOnlineRootPublicKey<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetNewOnlineRootPublicKey<S> {}
    impl<S: State> State for SetNewOnlineRootPublicKey<S> {
        type NewOnlineRootAlg = S::NewOnlineRootAlg;
        type NewOnlineRootPublicKey = Set<members::new_online_root_public_key>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `new_online_root_alg` field
        pub struct new_online_root_alg(());
        ///Marker type for the `new_online_root_public_key` field
        pub struct new_online_root_public_key(());
    }
}

/// Builder for constructing an instance of this type
pub struct RecoveryRotateOnlineRootBuilder<'a, S: recovery_rotate_online_root_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<bytes::Bytes>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> RecoveryRotateOnlineRoot<'a> {
    /// Create a new builder for this type
    pub fn new() -> RecoveryRotateOnlineRootBuilder<'a, recovery_rotate_online_root_state::Empty> {
        RecoveryRotateOnlineRootBuilder::new()
    }
}

impl<'a> RecoveryRotateOnlineRootBuilder<'a, recovery_rotate_online_root_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        RecoveryRotateOnlineRootBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> RecoveryRotateOnlineRootBuilder<'a, S>
where
    S: recovery_rotate_online_root_state::State,
    S::NewOnlineRootAlg: recovery_rotate_online_root_state::IsUnset,
{
    /// Set the `newOnlineRootAlg` field (required)
    pub fn new_online_root_alg(
        mut self,
        value: impl Into<jacquard_common::CowStr<'a>>,
    ) -> RecoveryRotateOnlineRootBuilder<
        'a,
        recovery_rotate_online_root_state::SetNewOnlineRootAlg<S>,
    > {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        RecoveryRotateOnlineRootBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> RecoveryRotateOnlineRootBuilder<'a, S>
where
    S: recovery_rotate_online_root_state::State,
    S::NewOnlineRootPublicKey: recovery_rotate_online_root_state::IsUnset,
{
    /// Set the `newOnlineRootPublicKey` field (required)
    pub fn new_online_root_public_key(
        mut self,
        value: impl Into<bytes::Bytes>,
    ) -> RecoveryRotateOnlineRootBuilder<
        'a,
        recovery_rotate_online_root_state::SetNewOnlineRootPublicKey<S>,
    > {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        RecoveryRotateOnlineRootBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: recovery_rotate_online_root_state::State> RecoveryRotateOnlineRootBuilder<'a, S> {
    /// Set the `recoveryReason` field (optional)
    pub fn recovery_reason(
        mut self,
        value: impl Into<Option<jacquard_common::CowStr<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.2 = value.into();
        self
    }
    /// Set the `recoveryReason` field to an Option value (optional)
    pub fn maybe_recovery_reason(mut self, value: Option<jacquard_common::CowStr<'a>>) -> Self {
        self.__unsafe_private_named.2 = value;
        self
    }
}

impl<'a, S> RecoveryRotateOnlineRootBuilder<'a, S>
where
    S: recovery_rotate_online_root_state::State,
    S::NewOnlineRootAlg: recovery_rotate_online_root_state::IsSet,
    S::NewOnlineRootPublicKey: recovery_rotate_online_root_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> RecoveryRotateOnlineRoot<'a> {
        RecoveryRotateOnlineRoot {
            new_online_root_alg: self.__unsafe_private_named.0.unwrap(),
            new_online_root_public_key: self.__unsafe_private_named.1.unwrap(),
            recovery_reason: self.__unsafe_private_named.2,
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> RecoveryRotateOnlineRoot<'a> {
        RecoveryRotateOnlineRoot {
            new_online_root_alg: self.__unsafe_private_named.0.unwrap(),
            new_online_root_public_key: self.__unsafe_private_named.1.unwrap(),
            recovery_reason: self.__unsafe_private_named.2,
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for RecoveryRotateOnlineRoot<'a> {
    fn nsid() -> &'static str {
        "blue.catbird.mlsChat.declaration"
    }
    fn def_name() -> &'static str {
        "recoveryRotateOnlineRoot"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_blue_catbird_mlsChat_declaration()
    }
    fn validate(
        &self,
    ) -> ::std::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        if let Some(ref value) = self.recovery_reason {
            #[allow(unused_comparisons)]
            if <str>::len(value.as_ref()) > 256usize {
                return Err(::jacquard_lexicon::validation::ConstraintError::MaxLength {
                    path: ::jacquard_lexicon::validation::ValidationPath::from_field(
                        "recovery_reason",
                    ),
                    max: 256usize,
                    actual: <str>::len(value.as_ref()),
                });
            }
        }
        Ok(())
    }
}

/// Initialize the declaration chain with root keys. Must be seq=0.
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq, jacquard_derive::IntoStatic,
)]
#[serde(rename_all = "camelCase")]
pub struct RootInit<'a> {
    /// Optional human-readable note (e.g., 'catbird-initialize')
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub note: std::option::Option<jacquard_common::CowStr<'a>>,
    /// Algorithm of the online root key (e.g., 'p256')
    #[serde(borrow)]
    pub online_root_alg: jacquard_common::CowStr<'a>,
    /// Public key of the online root (used for signing day-to-day declarations)
    #[serde(with = "jacquard_common::serde_bytes_helper")]
    pub online_root_public_key: bytes::Bytes,
    /// Algorithm of the recovery root key (e.g., 'p256')
    #[serde(borrow)]
    pub recovery_root_alg: jacquard_common::CowStr<'a>,
    /// Public key of the recovery root (used for emergency root rotation)
    #[serde(with = "jacquard_common::serde_bytes_helper")]
    pub recovery_root_public_key: bytes::Bytes,
}

pub mod root_init_state {

    pub use crate::builder_types::{IsSet, IsUnset, Set, Unset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type RecoveryRootAlg;
        type OnlineRootAlg;
        type OnlineRootPublicKey;
        type RecoveryRootPublicKey;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type RecoveryRootAlg = Unset;
        type OnlineRootAlg = Unset;
        type OnlineRootPublicKey = Unset;
        type RecoveryRootPublicKey = Unset;
    }
    ///State transition - sets the `recovery_root_alg` field to Set
    pub struct SetRecoveryRootAlg<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetRecoveryRootAlg<S> {}
    impl<S: State> State for SetRecoveryRootAlg<S> {
        type RecoveryRootAlg = Set<members::recovery_root_alg>;
        type OnlineRootAlg = S::OnlineRootAlg;
        type OnlineRootPublicKey = S::OnlineRootPublicKey;
        type RecoveryRootPublicKey = S::RecoveryRootPublicKey;
    }
    ///State transition - sets the `online_root_alg` field to Set
    pub struct SetOnlineRootAlg<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetOnlineRootAlg<S> {}
    impl<S: State> State for SetOnlineRootAlg<S> {
        type RecoveryRootAlg = S::RecoveryRootAlg;
        type OnlineRootAlg = Set<members::online_root_alg>;
        type OnlineRootPublicKey = S::OnlineRootPublicKey;
        type RecoveryRootPublicKey = S::RecoveryRootPublicKey;
    }
    ///State transition - sets the `online_root_public_key` field to Set
    pub struct SetOnlineRootPublicKey<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetOnlineRootPublicKey<S> {}
    impl<S: State> State for SetOnlineRootPublicKey<S> {
        type RecoveryRootAlg = S::RecoveryRootAlg;
        type OnlineRootAlg = S::OnlineRootAlg;
        type OnlineRootPublicKey = Set<members::online_root_public_key>;
        type RecoveryRootPublicKey = S::RecoveryRootPublicKey;
    }
    ///State transition - sets the `recovery_root_public_key` field to Set
    pub struct SetRecoveryRootPublicKey<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetRecoveryRootPublicKey<S> {}
    impl<S: State> State for SetRecoveryRootPublicKey<S> {
        type RecoveryRootAlg = S::RecoveryRootAlg;
        type OnlineRootAlg = S::OnlineRootAlg;
        type OnlineRootPublicKey = S::OnlineRootPublicKey;
        type RecoveryRootPublicKey = Set<members::recovery_root_public_key>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `recovery_root_alg` field
        pub struct recovery_root_alg(());
        ///Marker type for the `online_root_alg` field
        pub struct online_root_alg(());
        ///Marker type for the `online_root_public_key` field
        pub struct online_root_public_key(());
        ///Marker type for the `recovery_root_public_key` field
        pub struct recovery_root_public_key(());
    }
}

/// Builder for constructing an instance of this type
pub struct RootInitBuilder<'a, S: root_init_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<bytes::Bytes>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<bytes::Bytes>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> RootInit<'a> {
    /// Create a new builder for this type
    pub fn new() -> RootInitBuilder<'a, root_init_state::Empty> {
        RootInitBuilder::new()
    }
}

impl<'a> RootInitBuilder<'a, root_init_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        RootInitBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None, None, None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: root_init_state::State> RootInitBuilder<'a, S> {
    /// Set the `note` field (optional)
    pub fn note(mut self, value: impl Into<Option<jacquard_common::CowStr<'a>>>) -> Self {
        self.__unsafe_private_named.0 = value.into();
        self
    }
    /// Set the `note` field to an Option value (optional)
    pub fn maybe_note(mut self, value: Option<jacquard_common::CowStr<'a>>) -> Self {
        self.__unsafe_private_named.0 = value;
        self
    }
}

impl<'a, S> RootInitBuilder<'a, S>
where
    S: root_init_state::State,
    S::OnlineRootAlg: root_init_state::IsUnset,
{
    /// Set the `onlineRootAlg` field (required)
    pub fn online_root_alg(
        mut self,
        value: impl Into<jacquard_common::CowStr<'a>>,
    ) -> RootInitBuilder<'a, root_init_state::SetOnlineRootAlg<S>> {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        RootInitBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> RootInitBuilder<'a, S>
where
    S: root_init_state::State,
    S::OnlineRootPublicKey: root_init_state::IsUnset,
{
    /// Set the `onlineRootPublicKey` field (required)
    pub fn online_root_public_key(
        mut self,
        value: impl Into<bytes::Bytes>,
    ) -> RootInitBuilder<'a, root_init_state::SetOnlineRootPublicKey<S>> {
        self.__unsafe_private_named.2 = ::core::option::Option::Some(value.into());
        RootInitBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> RootInitBuilder<'a, S>
where
    S: root_init_state::State,
    S::RecoveryRootAlg: root_init_state::IsUnset,
{
    /// Set the `recoveryRootAlg` field (required)
    pub fn recovery_root_alg(
        mut self,
        value: impl Into<jacquard_common::CowStr<'a>>,
    ) -> RootInitBuilder<'a, root_init_state::SetRecoveryRootAlg<S>> {
        self.__unsafe_private_named.3 = ::core::option::Option::Some(value.into());
        RootInitBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> RootInitBuilder<'a, S>
where
    S: root_init_state::State,
    S::RecoveryRootPublicKey: root_init_state::IsUnset,
{
    /// Set the `recoveryRootPublicKey` field (required)
    pub fn recovery_root_public_key(
        mut self,
        value: impl Into<bytes::Bytes>,
    ) -> RootInitBuilder<'a, root_init_state::SetRecoveryRootPublicKey<S>> {
        self.__unsafe_private_named.4 = ::core::option::Option::Some(value.into());
        RootInitBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> RootInitBuilder<'a, S>
where
    S: root_init_state::State,
    S::RecoveryRootAlg: root_init_state::IsSet,
    S::OnlineRootAlg: root_init_state::IsSet,
    S::OnlineRootPublicKey: root_init_state::IsSet,
    S::RecoveryRootPublicKey: root_init_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> RootInit<'a> {
        RootInit {
            note: self.__unsafe_private_named.0,
            online_root_alg: self.__unsafe_private_named.1.unwrap(),
            online_root_public_key: self.__unsafe_private_named.2.unwrap(),
            recovery_root_alg: self.__unsafe_private_named.3.unwrap(),
            recovery_root_public_key: self.__unsafe_private_named.4.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> RootInit<'a> {
        RootInit {
            note: self.__unsafe_private_named.0,
            online_root_alg: self.__unsafe_private_named.1.unwrap(),
            online_root_public_key: self.__unsafe_private_named.2.unwrap(),
            recovery_root_alg: self.__unsafe_private_named.3.unwrap(),
            recovery_root_public_key: self.__unsafe_private_named.4.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for RootInit<'a> {
    fn nsid() -> &'static str {
        "blue.catbird.mlsChat.declaration"
    }
    fn def_name() -> &'static str {
        "rootInit"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_blue_catbird_mlsChat_declaration()
    }
    fn validate(
        &self,
    ) -> ::std::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        if let Some(ref value) = self.note {
            #[allow(unused_comparisons)]
            if <str>::len(value.as_ref()) > 256usize {
                return Err(::jacquard_lexicon::validation::ConstraintError::MaxLength {
                    path: ::jacquard_lexicon::validation::ValidationPath::from_field("note"),
                    max: 256usize,
                    actual: <str>::len(value.as_ref()),
                });
            }
        }
        Ok(())
    }
}

/// Rotate the online root key (signed by the old online root)
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq, jacquard_derive::IntoStatic,
)]
#[serde(rename_all = "camelCase")]
pub struct RootRotate<'a> {
    /// Algorithm of the new online root key
    #[serde(borrow)]
    pub new_online_root_alg: jacquard_common::CowStr<'a>,
    /// New online root public key
    #[serde(with = "jacquard_common::serde_bytes_helper")]
    pub new_online_root_public_key: bytes::Bytes,
    /// Rotation mode (e.g., 'normal', 'emergency')
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub rotation_mode: std::option::Option<jacquard_common::CowStr<'a>>,
}

pub mod root_rotate_state {

    pub use crate::builder_types::{IsSet, IsUnset, Set, Unset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type NewOnlineRootPublicKey;
        type NewOnlineRootAlg;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type NewOnlineRootPublicKey = Unset;
        type NewOnlineRootAlg = Unset;
    }
    ///State transition - sets the `new_online_root_public_key` field to Set
    pub struct SetNewOnlineRootPublicKey<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetNewOnlineRootPublicKey<S> {}
    impl<S: State> State for SetNewOnlineRootPublicKey<S> {
        type NewOnlineRootPublicKey = Set<members::new_online_root_public_key>;
        type NewOnlineRootAlg = S::NewOnlineRootAlg;
    }
    ///State transition - sets the `new_online_root_alg` field to Set
    pub struct SetNewOnlineRootAlg<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetNewOnlineRootAlg<S> {}
    impl<S: State> State for SetNewOnlineRootAlg<S> {
        type NewOnlineRootPublicKey = S::NewOnlineRootPublicKey;
        type NewOnlineRootAlg = Set<members::new_online_root_alg>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `new_online_root_public_key` field
        pub struct new_online_root_public_key(());
        ///Marker type for the `new_online_root_alg` field
        pub struct new_online_root_alg(());
    }
}

/// Builder for constructing an instance of this type
pub struct RootRotateBuilder<'a, S: root_rotate_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<bytes::Bytes>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> RootRotate<'a> {
    /// Create a new builder for this type
    pub fn new() -> RootRotateBuilder<'a, root_rotate_state::Empty> {
        RootRotateBuilder::new()
    }
}

impl<'a> RootRotateBuilder<'a, root_rotate_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        RootRotateBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> RootRotateBuilder<'a, S>
where
    S: root_rotate_state::State,
    S::NewOnlineRootAlg: root_rotate_state::IsUnset,
{
    /// Set the `newOnlineRootAlg` field (required)
    pub fn new_online_root_alg(
        mut self,
        value: impl Into<jacquard_common::CowStr<'a>>,
    ) -> RootRotateBuilder<'a, root_rotate_state::SetNewOnlineRootAlg<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        RootRotateBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> RootRotateBuilder<'a, S>
where
    S: root_rotate_state::State,
    S::NewOnlineRootPublicKey: root_rotate_state::IsUnset,
{
    /// Set the `newOnlineRootPublicKey` field (required)
    pub fn new_online_root_public_key(
        mut self,
        value: impl Into<bytes::Bytes>,
    ) -> RootRotateBuilder<'a, root_rotate_state::SetNewOnlineRootPublicKey<S>> {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        RootRotateBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: root_rotate_state::State> RootRotateBuilder<'a, S> {
    /// Set the `rotationMode` field (optional)
    pub fn rotation_mode(mut self, value: impl Into<Option<jacquard_common::CowStr<'a>>>) -> Self {
        self.__unsafe_private_named.2 = value.into();
        self
    }
    /// Set the `rotationMode` field to an Option value (optional)
    pub fn maybe_rotation_mode(mut self, value: Option<jacquard_common::CowStr<'a>>) -> Self {
        self.__unsafe_private_named.2 = value;
        self
    }
}

impl<'a, S> RootRotateBuilder<'a, S>
where
    S: root_rotate_state::State,
    S::NewOnlineRootPublicKey: root_rotate_state::IsSet,
    S::NewOnlineRootAlg: root_rotate_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> RootRotate<'a> {
        RootRotate {
            new_online_root_alg: self.__unsafe_private_named.0.unwrap(),
            new_online_root_public_key: self.__unsafe_private_named.1.unwrap(),
            rotation_mode: self.__unsafe_private_named.2,
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> RootRotate<'a> {
        RootRotate {
            new_online_root_alg: self.__unsafe_private_named.0.unwrap(),
            new_online_root_public_key: self.__unsafe_private_named.1.unwrap(),
            rotation_mode: self.__unsafe_private_named.2,
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for RootRotate<'a> {
    fn nsid() -> &'static str {
        "blue.catbird.mlsChat.declaration"
    }
    fn def_name() -> &'static str {
        "rootRotate"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_blue_catbird_mlsChat_declaration()
    }
    fn validate(
        &self,
    ) -> ::std::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        Ok(())
    }
}
