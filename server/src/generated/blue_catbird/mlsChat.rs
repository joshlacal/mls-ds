// @generated by jacquard-lexicon. DO NOT EDIT.
//
// Lexicon: blue.catbird.mlsChat.defs
//
// This file was automatically generated from Lexicon schemas.
// Any manual changes will be overwritten on the next regeneration.

pub mod blocks;
pub mod commit_group_change;
pub mod create_convo;
pub mod declaration;
pub mod get_convo_settings;
pub mod get_convos;
pub mod get_group_state;
pub mod get_key_package_status;
pub mod get_key_packages;
pub mod get_messages;
pub mod get_pending_devices;
pub mod get_reports;
pub mod get_subscription_ticket;
pub mod leave_convo;
pub mod list_devices;
pub mod opt_in;
pub mod publish_key_packages;
pub mod register_device;
pub mod report;
pub mod send_ephemeral;
pub mod send_message;

#[cfg(feature = "streaming")]
pub mod subscribe_events;
pub mod update_convo;
pub mod update_cursor;

/// Metadata for a conversation (name, description)
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    jacquard_derive::IntoStatic,
    Default,
)]
#[serde(rename_all = "camelCase")]
pub struct ConvoMetadata<'a> {
    /// Conversation description
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub description: std::option::Option<jacquard_common::CowStr<'a>>,
    /// Conversation display name
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub name: std::option::Option<jacquard_common::CowStr<'a>>,
}

fn lexicon_doc_blue_catbird_mlsChat_defs() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
    ::jacquard_lexicon::lexicon::LexiconDoc {
        lexicon: ::jacquard_lexicon::lexicon::Lexicon::Lexicon1,
        id: ::jacquard_common::CowStr::new_static("blue.catbird.mlsChat.defs"),
        revision: None,
        description: None,
        defs: {
            let mut map = ::std::collections::BTreeMap::new();
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("convoMetadata"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(
                    ::jacquard_lexicon::lexicon::LexObject {
                        description: Some(::jacquard_common::CowStr::new_static(
                            "Metadata for a conversation (name, description)",
                        )),
                        required: None,
                        nullable: None,
                        properties: {
                            #[allow(unused_mut)]
                            let mut map = ::std::collections::BTreeMap::new();
                            map.insert(
                                ::jacquard_common::smol_str::SmolStr::new_static("description"),
                                ::jacquard_lexicon::lexicon::LexObjectProperty::String(
                                    ::jacquard_lexicon::lexicon::LexString {
                                        description: Some(::jacquard_common::CowStr::new_static(
                                            "Conversation description",
                                        )),
                                        format: None,
                                        default: None,
                                        min_length: None,
                                        max_length: Some(512usize),
                                        min_graphemes: None,
                                        max_graphemes: None,
                                        r#enum: None,
                                        r#const: None,
                                        known_values: None,
                                    },
                                ),
                            );
                            map.insert(
                                ::jacquard_common::smol_str::SmolStr::new_static("name"),
                                ::jacquard_lexicon::lexicon::LexObjectProperty::String(
                                    ::jacquard_lexicon::lexicon::LexString {
                                        description: Some(::jacquard_common::CowStr::new_static(
                                            "Conversation display name",
                                        )),
                                        format: None,
                                        default: None,
                                        min_length: None,
                                        max_length: Some(128usize),
                                        min_graphemes: None,
                                        max_graphemes: None,
                                        r#enum: None,
                                        r#const: None,
                                        known_values: None,
                                    },
                                ),
                            );
                            map
                        },
                    },
                ),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("convoView"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "View of an MLS conversation with member and epoch information",
                        ),
                    ),
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("groupId"),
                            ::jacquard_common::smol_str::SmolStr::new_static("creator"),
                            ::jacquard_common::smol_str::SmolStr::new_static("members"),
                            ::jacquard_common::smol_str::SmolStr::new_static("epoch"),
                            ::jacquard_common::smol_str::SmolStr::new_static("cipherSuite"),
                            ::jacquard_common::smol_str::SmolStr::new_static("createdAt")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::std::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "cipherSuite",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "MLS cipher suite used for this conversation",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "createdAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Conversation creation timestamp",
                                    ),
                                ),
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("creator"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "DID of the conversation creator",
                                    ),
                                ),
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Did,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("epoch"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: Some(0i64),
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("groupId"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "MLS group identifier (hex-encoded) - canonical conversation ID",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: Some(128usize),
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "lastMessageAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Timestamp of last message",
                                    ),
                                ),
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("members"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Array(::jacquard_lexicon::lexicon::LexArray {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Current conversation members",
                                    ),
                                ),
                                items: ::jacquard_lexicon::lexicon::LexArrayItem::Ref(::jacquard_lexicon::lexicon::LexRef {
                                    description: None,
                                    r#ref: ::jacquard_common::CowStr::new_static("#memberView"),
                                }),
                                min_length: None,
                                max_length: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("metadata"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Ref(::jacquard_lexicon::lexicon::LexRef {
                                description: None,
                                r#ref: ::jacquard_common::CowStr::new_static(
                                    "#convoMetadata",
                                ),
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("keyPackageRef"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "Reference to an MLS key package for adding members",
                        ),
                    ),
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("did"),
                            ::jacquard_common::smol_str::SmolStr::new_static("keyPackage"),
                            ::jacquard_common::smol_str::SmolStr::new_static("cipherSuite")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::std::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "cipherSuite",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Supported cipher suite for this key package",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("did"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static("Owner DID"),
                                ),
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Did,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "keyPackage",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Base64url-encoded MLS key package bytes",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "keyPackageHash",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Hex-encoded SHA-256 hash of the key package bytes. Clients should use this server-computed hash when creating conversations to ensure hash consistency.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: Some(64usize),
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("memberView"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "View of a conversation member representing a single device. Multiple devices per user appear as separate members in MLS layer, but UI should group by userDid.",
                        ),
                    ),
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("did"),
                            ::jacquard_common::smol_str::SmolStr::new_static("userDid"),
                            ::jacquard_common::smol_str::SmolStr::new_static("joinedAt"),
                            ::jacquard_common::smol_str::SmolStr::new_static("isAdmin")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::std::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "credential",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Bytes(::jacquard_lexicon::lexicon::LexBytes {
                                description: None,
                                max_length: None,
                                min_length: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("deviceId"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Device identifier (UUID). Unique per device.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "deviceName",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Human-readable device name (e.g., 'Josh's iPhone'). Optional, may be null for legacy members.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: Some(128usize),
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("did"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Device-specific MLS DID (format: did:plc:user#device-uuid). Used in MLS operations.",
                                    ),
                                ),
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Did,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("isAdmin"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Boolean(::jacquard_lexicon::lexicon::LexBoolean {
                                description: None,
                                default: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "isModerator",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Boolean(::jacquard_lexicon::lexicon::LexBoolean {
                                description: None,
                                default: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("joinedAt"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "When this device joined the conversation",
                                    ),
                                ),
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "leafIndex",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: Some(0i64),
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "promotedAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "When member was promoted to admin (if applicable)",
                                    ),
                                ),
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "promotedBy",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "DID of admin who promoted this member (if applicable)",
                                    ),
                                ),
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Did,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("userDid"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "User DID without device suffix (format: did:plc:user). Used for UI grouping and admin status sync.",
                                    ),
                                ),
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Did,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map.insert(
                ::jacquard_common::smol_str::SmolStr::new_static("messageView"),
                ::jacquard_lexicon::lexicon::LexUserType::Object(::jacquard_lexicon::lexicon::LexObject {
                    description: Some(
                        ::jacquard_common::CowStr::new_static(
                            "View of an encrypted MLS message. Server follows 'dumb delivery service' model - sender identity must be derived by clients from decrypted MLS content for metadata privacy. Server GUARANTEES: (1) Sequential (epoch, seq) assignment per conversation, (2) Monotonic seq increment, (3) No seq reuse. Clients MUST process messages in (epoch ASC, seq ASC) order for correct MLS decryption.",
                        ),
                    ),
                    required: Some(
                        vec![
                            ::jacquard_common::smol_str::SmolStr::new_static("id"),
                            ::jacquard_common::smol_str::SmolStr::new_static("convoId"),
                            ::jacquard_common::smol_str::SmolStr::new_static("ciphertext"),
                            ::jacquard_common::smol_str::SmolStr::new_static("epoch"),
                            ::jacquard_common::smol_str::SmolStr::new_static("seq"),
                            ::jacquard_common::smol_str::SmolStr::new_static("createdAt")
                        ],
                    ),
                    nullable: None,
                    properties: {
                        #[allow(unused_mut)]
                        let mut map = ::std::collections::BTreeMap::new();
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "ciphertext",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Bytes(::jacquard_lexicon::lexicon::LexBytes {
                                description: None,
                                max_length: Some(10485760usize),
                                min_length: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("convoId"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Conversation identifier",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "createdAt",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Message creation timestamp (bucketed to 2-second intervals for traffic analysis protection)",
                                    ),
                                ),
                                format: Some(
                                    ::jacquard_lexicon::lexicon::LexStringFormat::Datetime,
                                ),
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("epoch"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: Some(0i64),
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("id"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Message identifier (ULID for deduplication)",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static(
                                "messageType",
                            ),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::String(::jacquard_lexicon::lexicon::LexString {
                                description: Some(
                                    ::jacquard_common::CowStr::new_static(
                                        "Message type discriminator: 'app' for application messages (user content), 'commit' for MLS protocol control messages (epoch changes, membership updates). Clients should process both types for MLS state tracking but only display 'app' messages in the UI.",
                                    ),
                                ),
                                format: None,
                                default: None,
                                min_length: None,
                                max_length: None,
                                min_graphemes: None,
                                max_graphemes: None,
                                r#enum: None,
                                r#const: None,
                                known_values: None,
                            }),
                        );
                        map.insert(
                            ::jacquard_common::smol_str::SmolStr::new_static("seq"),
                            ::jacquard_lexicon::lexicon::LexObjectProperty::Integer(::jacquard_lexicon::lexicon::LexInteger {
                                description: None,
                                default: None,
                                minimum: Some(0i64),
                                maximum: None,
                                r#enum: None,
                                r#const: None,
                            }),
                        );
                        map
                    },
                }),
            );
            map
        },
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for ConvoMetadata<'a> {
    fn nsid() -> &'static str {
        "blue.catbird.mlsChat.defs"
    }
    fn def_name() -> &'static str {
        "convoMetadata"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_blue_catbird_mlsChat_defs()
    }
    fn validate(
        &self,
    ) -> ::std::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        if let Some(ref value) = self.description {
            #[allow(unused_comparisons)]
            if <str>::len(value.as_ref()) > 512usize {
                return Err(::jacquard_lexicon::validation::ConstraintError::MaxLength {
                    path: ::jacquard_lexicon::validation::ValidationPath::from_field("description"),
                    max: 512usize,
                    actual: <str>::len(value.as_ref()),
                });
            }
        }
        if let Some(ref value) = self.name {
            #[allow(unused_comparisons)]
            if <str>::len(value.as_ref()) > 128usize {
                return Err(::jacquard_lexicon::validation::ConstraintError::MaxLength {
                    path: ::jacquard_lexicon::validation::ValidationPath::from_field("name"),
                    max: 128usize,
                    actual: <str>::len(value.as_ref()),
                });
            }
        }
        Ok(())
    }
}

/// View of an MLS conversation with member and epoch information
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq, jacquard_derive::IntoStatic,
)]
#[serde(rename_all = "camelCase")]
pub struct ConvoView<'a> {
    /// MLS cipher suite used for this conversation
    #[serde(borrow)]
    pub cipher_suite: jacquard_common::CowStr<'a>,
    /// Conversation creation timestamp
    pub created_at: jacquard_common::types::string::Datetime,
    /// DID of the conversation creator
    #[serde(borrow)]
    pub creator: jacquard_common::types::string::Did<'a>,
    /// Current MLS epoch number
    pub epoch: i64,
    /// MLS group identifier (hex-encoded) - canonical conversation ID
    #[serde(borrow)]
    pub group_id: jacquard_common::CowStr<'a>,
    /// Timestamp of last message
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_message_at: std::option::Option<jacquard_common::types::string::Datetime>,
    /// Current conversation members
    #[serde(borrow)]
    pub members: Vec<crate::generated::blue_catbird::mlsChat::MemberView<'a>>,
    /// Optional conversation metadata
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub metadata: std::option::Option<crate::generated::blue_catbird::mlsChat::ConvoMetadata<'a>>,
}

pub mod convo_view_state {

    pub use crate::builder_types::{IsSet, IsUnset, Set, Unset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type GroupId;
        type Members;
        type Creator;
        type Epoch;
        type CipherSuite;
        type CreatedAt;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type GroupId = Unset;
        type Members = Unset;
        type Creator = Unset;
        type Epoch = Unset;
        type CipherSuite = Unset;
        type CreatedAt = Unset;
    }
    ///State transition - sets the `group_id` field to Set
    pub struct SetGroupId<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetGroupId<S> {}
    impl<S: State> State for SetGroupId<S> {
        type GroupId = Set<members::group_id>;
        type Members = S::Members;
        type Creator = S::Creator;
        type Epoch = S::Epoch;
        type CipherSuite = S::CipherSuite;
        type CreatedAt = S::CreatedAt;
    }
    ///State transition - sets the `members` field to Set
    pub struct SetMembers<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetMembers<S> {}
    impl<S: State> State for SetMembers<S> {
        type GroupId = S::GroupId;
        type Members = Set<members::members>;
        type Creator = S::Creator;
        type Epoch = S::Epoch;
        type CipherSuite = S::CipherSuite;
        type CreatedAt = S::CreatedAt;
    }
    ///State transition - sets the `creator` field to Set
    pub struct SetCreator<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetCreator<S> {}
    impl<S: State> State for SetCreator<S> {
        type GroupId = S::GroupId;
        type Members = S::Members;
        type Creator = Set<members::creator>;
        type Epoch = S::Epoch;
        type CipherSuite = S::CipherSuite;
        type CreatedAt = S::CreatedAt;
    }
    ///State transition - sets the `epoch` field to Set
    pub struct SetEpoch<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetEpoch<S> {}
    impl<S: State> State for SetEpoch<S> {
        type GroupId = S::GroupId;
        type Members = S::Members;
        type Creator = S::Creator;
        type Epoch = Set<members::epoch>;
        type CipherSuite = S::CipherSuite;
        type CreatedAt = S::CreatedAt;
    }
    ///State transition - sets the `cipher_suite` field to Set
    pub struct SetCipherSuite<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetCipherSuite<S> {}
    impl<S: State> State for SetCipherSuite<S> {
        type GroupId = S::GroupId;
        type Members = S::Members;
        type Creator = S::Creator;
        type Epoch = S::Epoch;
        type CipherSuite = Set<members::cipher_suite>;
        type CreatedAt = S::CreatedAt;
    }
    ///State transition - sets the `created_at` field to Set
    pub struct SetCreatedAt<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetCreatedAt<S> {}
    impl<S: State> State for SetCreatedAt<S> {
        type GroupId = S::GroupId;
        type Members = S::Members;
        type Creator = S::Creator;
        type Epoch = S::Epoch;
        type CipherSuite = S::CipherSuite;
        type CreatedAt = Set<members::created_at>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `group_id` field
        pub struct group_id(());
        ///Marker type for the `members` field
        pub struct members(());
        ///Marker type for the `creator` field
        pub struct creator(());
        ///Marker type for the `epoch` field
        pub struct epoch(());
        ///Marker type for the `cipher_suite` field
        pub struct cipher_suite(());
        ///Marker type for the `created_at` field
        pub struct created_at(());
    }
}

/// Builder for constructing an instance of this type
pub struct ConvoViewBuilder<'a, S: convo_view_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<jacquard_common::types::string::Datetime>,
        ::core::option::Option<jacquard_common::types::string::Did<'a>>,
        ::core::option::Option<i64>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<jacquard_common::types::string::Datetime>,
        ::core::option::Option<Vec<crate::generated::blue_catbird::mlsChat::MemberView<'a>>>,
        ::core::option::Option<crate::generated::blue_catbird::mlsChat::ConvoMetadata<'a>>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> ConvoView<'a> {
    /// Create a new builder for this type
    pub fn new() -> ConvoViewBuilder<'a, convo_view_state::Empty> {
        ConvoViewBuilder::new()
    }
}

impl<'a> ConvoViewBuilder<'a, convo_view_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        ConvoViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None, None, None, None, None, None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ConvoViewBuilder<'a, S>
where
    S: convo_view_state::State,
    S::CipherSuite: convo_view_state::IsUnset,
{
    /// Set the `cipherSuite` field (required)
    pub fn cipher_suite(
        mut self,
        value: impl Into<jacquard_common::CowStr<'a>>,
    ) -> ConvoViewBuilder<'a, convo_view_state::SetCipherSuite<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        ConvoViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ConvoViewBuilder<'a, S>
where
    S: convo_view_state::State,
    S::CreatedAt: convo_view_state::IsUnset,
{
    /// Set the `createdAt` field (required)
    pub fn created_at(
        mut self,
        value: impl Into<jacquard_common::types::string::Datetime>,
    ) -> ConvoViewBuilder<'a, convo_view_state::SetCreatedAt<S>> {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        ConvoViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ConvoViewBuilder<'a, S>
where
    S: convo_view_state::State,
    S::Creator: convo_view_state::IsUnset,
{
    /// Set the `creator` field (required)
    pub fn creator(
        mut self,
        value: impl Into<jacquard_common::types::string::Did<'a>>,
    ) -> ConvoViewBuilder<'a, convo_view_state::SetCreator<S>> {
        self.__unsafe_private_named.2 = ::core::option::Option::Some(value.into());
        ConvoViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ConvoViewBuilder<'a, S>
where
    S: convo_view_state::State,
    S::Epoch: convo_view_state::IsUnset,
{
    /// Set the `epoch` field (required)
    pub fn epoch(
        mut self,
        value: impl Into<i64>,
    ) -> ConvoViewBuilder<'a, convo_view_state::SetEpoch<S>> {
        self.__unsafe_private_named.3 = ::core::option::Option::Some(value.into());
        ConvoViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> ConvoViewBuilder<'a, S>
where
    S: convo_view_state::State,
    S::GroupId: convo_view_state::IsUnset,
{
    /// Set the `groupId` field (required)
    pub fn group_id(
        mut self,
        value: impl Into<jacquard_common::CowStr<'a>>,
    ) -> ConvoViewBuilder<'a, convo_view_state::SetGroupId<S>> {
        self.__unsafe_private_named.4 = ::core::option::Option::Some(value.into());
        ConvoViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: convo_view_state::State> ConvoViewBuilder<'a, S> {
    /// Set the `lastMessageAt` field (optional)
    pub fn last_message_at(
        mut self,
        value: impl Into<Option<jacquard_common::types::string::Datetime>>,
    ) -> Self {
        self.__unsafe_private_named.5 = value.into();
        self
    }
    /// Set the `lastMessageAt` field to an Option value (optional)
    pub fn maybe_last_message_at(
        mut self,
        value: Option<jacquard_common::types::string::Datetime>,
    ) -> Self {
        self.__unsafe_private_named.5 = value;
        self
    }
}

impl<'a, S> ConvoViewBuilder<'a, S>
where
    S: convo_view_state::State,
    S::Members: convo_view_state::IsUnset,
{
    /// Set the `members` field (required)
    pub fn members(
        mut self,
        value: impl Into<Vec<crate::generated::blue_catbird::mlsChat::MemberView<'a>>>,
    ) -> ConvoViewBuilder<'a, convo_view_state::SetMembers<S>> {
        self.__unsafe_private_named.6 = ::core::option::Option::Some(value.into());
        ConvoViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: convo_view_state::State> ConvoViewBuilder<'a, S> {
    /// Set the `metadata` field (optional)
    pub fn metadata(
        mut self,
        value: impl Into<Option<crate::generated::blue_catbird::mlsChat::ConvoMetadata<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.7 = value.into();
        self
    }
    /// Set the `metadata` field to an Option value (optional)
    pub fn maybe_metadata(
        mut self,
        value: Option<crate::generated::blue_catbird::mlsChat::ConvoMetadata<'a>>,
    ) -> Self {
        self.__unsafe_private_named.7 = value;
        self
    }
}

impl<'a, S> ConvoViewBuilder<'a, S>
where
    S: convo_view_state::State,
    S::GroupId: convo_view_state::IsSet,
    S::Members: convo_view_state::IsSet,
    S::Creator: convo_view_state::IsSet,
    S::Epoch: convo_view_state::IsSet,
    S::CipherSuite: convo_view_state::IsSet,
    S::CreatedAt: convo_view_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> ConvoView<'a> {
        ConvoView {
            cipher_suite: self.__unsafe_private_named.0.unwrap(),
            created_at: self.__unsafe_private_named.1.unwrap(),
            creator: self.__unsafe_private_named.2.unwrap(),
            epoch: self.__unsafe_private_named.3.unwrap(),
            group_id: self.__unsafe_private_named.4.unwrap(),
            last_message_at: self.__unsafe_private_named.5,
            members: self.__unsafe_private_named.6.unwrap(),
            metadata: self.__unsafe_private_named.7,
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> ConvoView<'a> {
        ConvoView {
            cipher_suite: self.__unsafe_private_named.0.unwrap(),
            created_at: self.__unsafe_private_named.1.unwrap(),
            creator: self.__unsafe_private_named.2.unwrap(),
            epoch: self.__unsafe_private_named.3.unwrap(),
            group_id: self.__unsafe_private_named.4.unwrap(),
            last_message_at: self.__unsafe_private_named.5,
            members: self.__unsafe_private_named.6.unwrap(),
            metadata: self.__unsafe_private_named.7,
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for ConvoView<'a> {
    fn nsid() -> &'static str {
        "blue.catbird.mlsChat.defs"
    }
    fn def_name() -> &'static str {
        "convoView"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_blue_catbird_mlsChat_defs()
    }
    fn validate(
        &self,
    ) -> ::std::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        {
            let value = &self.epoch;
            if *value < 0i64 {
                return Err(::jacquard_lexicon::validation::ConstraintError::Minimum {
                    path: ::jacquard_lexicon::validation::ValidationPath::from_field("epoch"),
                    min: 0i64,
                    actual: *value,
                });
            }
        }
        {
            let value = &self.group_id;
            #[allow(unused_comparisons)]
            if <str>::len(value.as_ref()) > 128usize {
                return Err(::jacquard_lexicon::validation::ConstraintError::MaxLength {
                    path: ::jacquard_lexicon::validation::ValidationPath::from_field("group_id"),
                    max: 128usize,
                    actual: <str>::len(value.as_ref()),
                });
            }
        }
        Ok(())
    }
}

/// Reference to an MLS key package for adding members
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq, jacquard_derive::IntoStatic,
)]
#[serde(rename_all = "camelCase")]
pub struct KeyPackageRef<'a> {
    /// Supported cipher suite for this key package
    #[serde(borrow)]
    pub cipher_suite: jacquard_common::CowStr<'a>,
    /// Owner DID
    #[serde(borrow)]
    pub did: jacquard_common::types::string::Did<'a>,
    /// Base64url-encoded MLS key package bytes
    #[serde(borrow)]
    pub key_package: jacquard_common::CowStr<'a>,
    /// Hex-encoded SHA-256 hash of the key package bytes. Clients should use this server-computed hash when creating conversations to ensure hash consistency.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub key_package_hash: std::option::Option<jacquard_common::CowStr<'a>>,
}

pub mod key_package_ref_state {

    pub use crate::builder_types::{IsSet, IsUnset, Set, Unset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type Did;
        type KeyPackage;
        type CipherSuite;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type Did = Unset;
        type KeyPackage = Unset;
        type CipherSuite = Unset;
    }
    ///State transition - sets the `did` field to Set
    pub struct SetDid<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetDid<S> {}
    impl<S: State> State for SetDid<S> {
        type Did = Set<members::did>;
        type KeyPackage = S::KeyPackage;
        type CipherSuite = S::CipherSuite;
    }
    ///State transition - sets the `key_package` field to Set
    pub struct SetKeyPackage<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetKeyPackage<S> {}
    impl<S: State> State for SetKeyPackage<S> {
        type Did = S::Did;
        type KeyPackage = Set<members::key_package>;
        type CipherSuite = S::CipherSuite;
    }
    ///State transition - sets the `cipher_suite` field to Set
    pub struct SetCipherSuite<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetCipherSuite<S> {}
    impl<S: State> State for SetCipherSuite<S> {
        type Did = S::Did;
        type KeyPackage = S::KeyPackage;
        type CipherSuite = Set<members::cipher_suite>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `did` field
        pub struct did(());
        ///Marker type for the `key_package` field
        pub struct key_package(());
        ///Marker type for the `cipher_suite` field
        pub struct cipher_suite(());
    }
}

/// Builder for constructing an instance of this type
pub struct KeyPackageRefBuilder<'a, S: key_package_ref_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<jacquard_common::types::string::Did<'a>>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> KeyPackageRef<'a> {
    /// Create a new builder for this type
    pub fn new() -> KeyPackageRefBuilder<'a, key_package_ref_state::Empty> {
        KeyPackageRefBuilder::new()
    }
}

impl<'a> KeyPackageRefBuilder<'a, key_package_ref_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        KeyPackageRefBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None, None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> KeyPackageRefBuilder<'a, S>
where
    S: key_package_ref_state::State,
    S::CipherSuite: key_package_ref_state::IsUnset,
{
    /// Set the `cipherSuite` field (required)
    pub fn cipher_suite(
        mut self,
        value: impl Into<jacquard_common::CowStr<'a>>,
    ) -> KeyPackageRefBuilder<'a, key_package_ref_state::SetCipherSuite<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        KeyPackageRefBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> KeyPackageRefBuilder<'a, S>
where
    S: key_package_ref_state::State,
    S::Did: key_package_ref_state::IsUnset,
{
    /// Set the `did` field (required)
    pub fn did(
        mut self,
        value: impl Into<jacquard_common::types::string::Did<'a>>,
    ) -> KeyPackageRefBuilder<'a, key_package_ref_state::SetDid<S>> {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        KeyPackageRefBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> KeyPackageRefBuilder<'a, S>
where
    S: key_package_ref_state::State,
    S::KeyPackage: key_package_ref_state::IsUnset,
{
    /// Set the `keyPackage` field (required)
    pub fn key_package(
        mut self,
        value: impl Into<jacquard_common::CowStr<'a>>,
    ) -> KeyPackageRefBuilder<'a, key_package_ref_state::SetKeyPackage<S>> {
        self.__unsafe_private_named.2 = ::core::option::Option::Some(value.into());
        KeyPackageRefBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: key_package_ref_state::State> KeyPackageRefBuilder<'a, S> {
    /// Set the `keyPackageHash` field (optional)
    pub fn key_package_hash(
        mut self,
        value: impl Into<Option<jacquard_common::CowStr<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.3 = value.into();
        self
    }
    /// Set the `keyPackageHash` field to an Option value (optional)
    pub fn maybe_key_package_hash(mut self, value: Option<jacquard_common::CowStr<'a>>) -> Self {
        self.__unsafe_private_named.3 = value;
        self
    }
}

impl<'a, S> KeyPackageRefBuilder<'a, S>
where
    S: key_package_ref_state::State,
    S::Did: key_package_ref_state::IsSet,
    S::KeyPackage: key_package_ref_state::IsSet,
    S::CipherSuite: key_package_ref_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> KeyPackageRef<'a> {
        KeyPackageRef {
            cipher_suite: self.__unsafe_private_named.0.unwrap(),
            did: self.__unsafe_private_named.1.unwrap(),
            key_package: self.__unsafe_private_named.2.unwrap(),
            key_package_hash: self.__unsafe_private_named.3,
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> KeyPackageRef<'a> {
        KeyPackageRef {
            cipher_suite: self.__unsafe_private_named.0.unwrap(),
            did: self.__unsafe_private_named.1.unwrap(),
            key_package: self.__unsafe_private_named.2.unwrap(),
            key_package_hash: self.__unsafe_private_named.3,
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for KeyPackageRef<'a> {
    fn nsid() -> &'static str {
        "blue.catbird.mlsChat.defs"
    }
    fn def_name() -> &'static str {
        "keyPackageRef"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_blue_catbird_mlsChat_defs()
    }
    fn validate(
        &self,
    ) -> ::std::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        if let Some(ref value) = self.key_package_hash {
            #[allow(unused_comparisons)]
            if <str>::len(value.as_ref()) > 64usize {
                return Err(::jacquard_lexicon::validation::ConstraintError::MaxLength {
                    path: ::jacquard_lexicon::validation::ValidationPath::from_field(
                        "key_package_hash",
                    ),
                    max: 64usize,
                    actual: <str>::len(value.as_ref()),
                });
            }
        }
        Ok(())
    }
}

/// View of a conversation member representing a single device. Multiple devices per user appear as separate members in MLS layer, but UI should group by userDid.
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq, jacquard_derive::IntoStatic,
)]
#[serde(rename_all = "camelCase")]
pub struct MemberView<'a> {
    /// MLS credential bytes
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(default, with = "jacquard_common::opt_serde_bytes_helper")]
    pub credential: std::option::Option<bytes::Bytes>,
    /// Device identifier (UUID). Unique per device.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub device_id: std::option::Option<jacquard_common::CowStr<'a>>,
    /// Human-readable device name (e.g., 'Josh's iPhone'). Optional, may be null for legacy members.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub device_name: std::option::Option<jacquard_common::CowStr<'a>>,
    /// Device-specific MLS DID (format: did:plc:user#device-uuid). Used in MLS operations.
    #[serde(borrow)]
    pub did: jacquard_common::types::string::Did<'a>,
    /// Whether this member (device) has admin privileges. Admin status is synced across all devices of the same user.
    pub is_admin: bool,
    /// Whether this member has moderator privileges. Moderators can warn members and view reports but cannot promote/demote others.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub is_moderator: std::option::Option<bool>,
    /// When this device joined the conversation
    pub joined_at: jacquard_common::types::string::Datetime,
    /// MLS leaf index in ratchet tree structure
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub leaf_index: std::option::Option<i64>,
    /// When member was promoted to admin (if applicable)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub promoted_at: std::option::Option<jacquard_common::types::string::Datetime>,
    /// DID of admin who promoted this member (if applicable)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub promoted_by: std::option::Option<jacquard_common::types::string::Did<'a>>,
    /// User DID without device suffix (format: did:plc:user). Used for UI grouping and admin status sync.
    #[serde(borrow)]
    pub user_did: jacquard_common::types::string::Did<'a>,
}

pub mod member_view_state {

    pub use crate::builder_types::{IsSet, IsUnset, Set, Unset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type UserDid;
        type JoinedAt;
        type Did;
        type IsAdmin;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type UserDid = Unset;
        type JoinedAt = Unset;
        type Did = Unset;
        type IsAdmin = Unset;
    }
    ///State transition - sets the `user_did` field to Set
    pub struct SetUserDid<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetUserDid<S> {}
    impl<S: State> State for SetUserDid<S> {
        type UserDid = Set<members::user_did>;
        type JoinedAt = S::JoinedAt;
        type Did = S::Did;
        type IsAdmin = S::IsAdmin;
    }
    ///State transition - sets the `joined_at` field to Set
    pub struct SetJoinedAt<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetJoinedAt<S> {}
    impl<S: State> State for SetJoinedAt<S> {
        type UserDid = S::UserDid;
        type JoinedAt = Set<members::joined_at>;
        type Did = S::Did;
        type IsAdmin = S::IsAdmin;
    }
    ///State transition - sets the `did` field to Set
    pub struct SetDid<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetDid<S> {}
    impl<S: State> State for SetDid<S> {
        type UserDid = S::UserDid;
        type JoinedAt = S::JoinedAt;
        type Did = Set<members::did>;
        type IsAdmin = S::IsAdmin;
    }
    ///State transition - sets the `is_admin` field to Set
    pub struct SetIsAdmin<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetIsAdmin<S> {}
    impl<S: State> State for SetIsAdmin<S> {
        type UserDid = S::UserDid;
        type JoinedAt = S::JoinedAt;
        type Did = S::Did;
        type IsAdmin = Set<members::is_admin>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `user_did` field
        pub struct user_did(());
        ///Marker type for the `joined_at` field
        pub struct joined_at(());
        ///Marker type for the `did` field
        pub struct did(());
        ///Marker type for the `is_admin` field
        pub struct is_admin(());
    }
}

/// Builder for constructing an instance of this type
pub struct MemberViewBuilder<'a, S: member_view_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<bytes::Bytes>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<jacquard_common::types::string::Did<'a>>,
        ::core::option::Option<bool>,
        ::core::option::Option<bool>,
        ::core::option::Option<jacquard_common::types::string::Datetime>,
        ::core::option::Option<i64>,
        ::core::option::Option<jacquard_common::types::string::Datetime>,
        ::core::option::Option<jacquard_common::types::string::Did<'a>>,
        ::core::option::Option<jacquard_common::types::string::Did<'a>>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> MemberView<'a> {
    /// Create a new builder for this type
    pub fn new() -> MemberViewBuilder<'a, member_view_state::Empty> {
        MemberViewBuilder::new()
    }
}

impl<'a> MemberViewBuilder<'a, member_view_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        MemberViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (
                None, None, None, None, None, None, None, None, None, None, None,
            ),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: member_view_state::State> MemberViewBuilder<'a, S> {
    /// Set the `credential` field (optional)
    pub fn credential(mut self, value: impl Into<Option<bytes::Bytes>>) -> Self {
        self.__unsafe_private_named.0 = value.into();
        self
    }
    /// Set the `credential` field to an Option value (optional)
    pub fn maybe_credential(mut self, value: Option<bytes::Bytes>) -> Self {
        self.__unsafe_private_named.0 = value;
        self
    }
}

impl<'a, S: member_view_state::State> MemberViewBuilder<'a, S> {
    /// Set the `deviceId` field (optional)
    pub fn device_id(mut self, value: impl Into<Option<jacquard_common::CowStr<'a>>>) -> Self {
        self.__unsafe_private_named.1 = value.into();
        self
    }
    /// Set the `deviceId` field to an Option value (optional)
    pub fn maybe_device_id(mut self, value: Option<jacquard_common::CowStr<'a>>) -> Self {
        self.__unsafe_private_named.1 = value;
        self
    }
}

impl<'a, S: member_view_state::State> MemberViewBuilder<'a, S> {
    /// Set the `deviceName` field (optional)
    pub fn device_name(mut self, value: impl Into<Option<jacquard_common::CowStr<'a>>>) -> Self {
        self.__unsafe_private_named.2 = value.into();
        self
    }
    /// Set the `deviceName` field to an Option value (optional)
    pub fn maybe_device_name(mut self, value: Option<jacquard_common::CowStr<'a>>) -> Self {
        self.__unsafe_private_named.2 = value;
        self
    }
}

impl<'a, S> MemberViewBuilder<'a, S>
where
    S: member_view_state::State,
    S::Did: member_view_state::IsUnset,
{
    /// Set the `did` field (required)
    pub fn did(
        mut self,
        value: impl Into<jacquard_common::types::string::Did<'a>>,
    ) -> MemberViewBuilder<'a, member_view_state::SetDid<S>> {
        self.__unsafe_private_named.3 = ::core::option::Option::Some(value.into());
        MemberViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> MemberViewBuilder<'a, S>
where
    S: member_view_state::State,
    S::IsAdmin: member_view_state::IsUnset,
{
    /// Set the `isAdmin` field (required)
    pub fn is_admin(
        mut self,
        value: impl Into<bool>,
    ) -> MemberViewBuilder<'a, member_view_state::SetIsAdmin<S>> {
        self.__unsafe_private_named.4 = ::core::option::Option::Some(value.into());
        MemberViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: member_view_state::State> MemberViewBuilder<'a, S> {
    /// Set the `isModerator` field (optional)
    pub fn is_moderator(mut self, value: impl Into<Option<bool>>) -> Self {
        self.__unsafe_private_named.5 = value.into();
        self
    }
    /// Set the `isModerator` field to an Option value (optional)
    pub fn maybe_is_moderator(mut self, value: Option<bool>) -> Self {
        self.__unsafe_private_named.5 = value;
        self
    }
}

impl<'a, S> MemberViewBuilder<'a, S>
where
    S: member_view_state::State,
    S::JoinedAt: member_view_state::IsUnset,
{
    /// Set the `joinedAt` field (required)
    pub fn joined_at(
        mut self,
        value: impl Into<jacquard_common::types::string::Datetime>,
    ) -> MemberViewBuilder<'a, member_view_state::SetJoinedAt<S>> {
        self.__unsafe_private_named.6 = ::core::option::Option::Some(value.into());
        MemberViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: member_view_state::State> MemberViewBuilder<'a, S> {
    /// Set the `leafIndex` field (optional)
    pub fn leaf_index(mut self, value: impl Into<Option<i64>>) -> Self {
        self.__unsafe_private_named.7 = value.into();
        self
    }
    /// Set the `leafIndex` field to an Option value (optional)
    pub fn maybe_leaf_index(mut self, value: Option<i64>) -> Self {
        self.__unsafe_private_named.7 = value;
        self
    }
}

impl<'a, S: member_view_state::State> MemberViewBuilder<'a, S> {
    /// Set the `promotedAt` field (optional)
    pub fn promoted_at(
        mut self,
        value: impl Into<Option<jacquard_common::types::string::Datetime>>,
    ) -> Self {
        self.__unsafe_private_named.8 = value.into();
        self
    }
    /// Set the `promotedAt` field to an Option value (optional)
    pub fn maybe_promoted_at(
        mut self,
        value: Option<jacquard_common::types::string::Datetime>,
    ) -> Self {
        self.__unsafe_private_named.8 = value;
        self
    }
}

impl<'a, S: member_view_state::State> MemberViewBuilder<'a, S> {
    /// Set the `promotedBy` field (optional)
    pub fn promoted_by(
        mut self,
        value: impl Into<Option<jacquard_common::types::string::Did<'a>>>,
    ) -> Self {
        self.__unsafe_private_named.9 = value.into();
        self
    }
    /// Set the `promotedBy` field to an Option value (optional)
    pub fn maybe_promoted_by(
        mut self,
        value: Option<jacquard_common::types::string::Did<'a>>,
    ) -> Self {
        self.__unsafe_private_named.9 = value;
        self
    }
}

impl<'a, S> MemberViewBuilder<'a, S>
where
    S: member_view_state::State,
    S::UserDid: member_view_state::IsUnset,
{
    /// Set the `userDid` field (required)
    pub fn user_did(
        mut self,
        value: impl Into<jacquard_common::types::string::Did<'a>>,
    ) -> MemberViewBuilder<'a, member_view_state::SetUserDid<S>> {
        self.__unsafe_private_named.10 = ::core::option::Option::Some(value.into());
        MemberViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> MemberViewBuilder<'a, S>
where
    S: member_view_state::State,
    S::UserDid: member_view_state::IsSet,
    S::JoinedAt: member_view_state::IsSet,
    S::Did: member_view_state::IsSet,
    S::IsAdmin: member_view_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> MemberView<'a> {
        MemberView {
            credential: self.__unsafe_private_named.0,
            device_id: self.__unsafe_private_named.1,
            device_name: self.__unsafe_private_named.2,
            did: self.__unsafe_private_named.3.unwrap(),
            is_admin: self.__unsafe_private_named.4.unwrap(),
            is_moderator: self.__unsafe_private_named.5,
            joined_at: self.__unsafe_private_named.6.unwrap(),
            leaf_index: self.__unsafe_private_named.7,
            promoted_at: self.__unsafe_private_named.8,
            promoted_by: self.__unsafe_private_named.9,
            user_did: self.__unsafe_private_named.10.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> MemberView<'a> {
        MemberView {
            credential: self.__unsafe_private_named.0,
            device_id: self.__unsafe_private_named.1,
            device_name: self.__unsafe_private_named.2,
            did: self.__unsafe_private_named.3.unwrap(),
            is_admin: self.__unsafe_private_named.4.unwrap(),
            is_moderator: self.__unsafe_private_named.5,
            joined_at: self.__unsafe_private_named.6.unwrap(),
            leaf_index: self.__unsafe_private_named.7,
            promoted_at: self.__unsafe_private_named.8,
            promoted_by: self.__unsafe_private_named.9,
            user_did: self.__unsafe_private_named.10.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for MemberView<'a> {
    fn nsid() -> &'static str {
        "blue.catbird.mlsChat.defs"
    }
    fn def_name() -> &'static str {
        "memberView"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_blue_catbird_mlsChat_defs()
    }
    fn validate(
        &self,
    ) -> ::std::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        if let Some(ref value) = self.device_name {
            #[allow(unused_comparisons)]
            if <str>::len(value.as_ref()) > 128usize {
                return Err(::jacquard_lexicon::validation::ConstraintError::MaxLength {
                    path: ::jacquard_lexicon::validation::ValidationPath::from_field("device_name"),
                    max: 128usize,
                    actual: <str>::len(value.as_ref()),
                });
            }
        }
        if let Some(ref value) = self.leaf_index {
            if *value < 0i64 {
                return Err(::jacquard_lexicon::validation::ConstraintError::Minimum {
                    path: ::jacquard_lexicon::validation::ValidationPath::from_field("leaf_index"),
                    min: 0i64,
                    actual: *value,
                });
            }
        }
        Ok(())
    }
}

/// View of an encrypted MLS message. Server follows 'dumb delivery service' model - sender identity must be derived by clients from decrypted MLS content for metadata privacy. Server GUARANTEES: (1) Sequential (epoch, seq) assignment per conversation, (2) Monotonic seq increment, (3) No seq reuse. Clients MUST process messages in (epoch ASC, seq ASC) order for correct MLS decryption.
#[jacquard_derive::lexicon]
#[derive(
    serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq, jacquard_derive::IntoStatic,
)]
#[serde(rename_all = "camelCase")]
pub struct MessageView<'a> {
    /// MLS encrypted message ciphertext bytes
    #[serde(with = "jacquard_common::serde_bytes_helper")]
    pub ciphertext: bytes::Bytes,
    /// Conversation identifier
    #[serde(borrow)]
    pub convo_id: jacquard_common::CowStr<'a>,
    /// Message creation timestamp (bucketed to 2-second intervals for traffic analysis protection)
    pub created_at: jacquard_common::types::string::Datetime,
    /// MLS epoch when message was sent
    pub epoch: i64,
    /// Message identifier (ULID for deduplication)
    #[serde(borrow)]
    pub id: jacquard_common::CowStr<'a>,
    /// Message type discriminator: 'app' for application messages (user content), 'commit' for MLS protocol control messages (epoch changes, membership updates). Clients should process both types for MLS state tracking but only display 'app' messages in the UI.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde(borrow)]
    pub message_type: std::option::Option<jacquard_common::CowStr<'a>>,
    /// Monotonically increasing sequence number within conversation. Server assigns sequentially starting from 1. Gaps may occur when members are removed from the conversation, but seq values are never reused.
    pub seq: i64,
}

pub mod message_view_state {

    pub use crate::builder_types::{IsSet, IsUnset, Set, Unset};
    #[allow(unused)]
    use ::core::marker::PhantomData;
    mod sealed {
        pub trait Sealed {}
    }
    /// State trait tracking which required fields have been set
    pub trait State: sealed::Sealed {
        type CreatedAt;
        type Ciphertext;
        type Id;
        type Epoch;
        type Seq;
        type ConvoId;
    }
    /// Empty state - all required fields are unset
    pub struct Empty(());
    impl sealed::Sealed for Empty {}
    impl State for Empty {
        type CreatedAt = Unset;
        type Ciphertext = Unset;
        type Id = Unset;
        type Epoch = Unset;
        type Seq = Unset;
        type ConvoId = Unset;
    }
    ///State transition - sets the `created_at` field to Set
    pub struct SetCreatedAt<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetCreatedAt<S> {}
    impl<S: State> State for SetCreatedAt<S> {
        type CreatedAt = Set<members::created_at>;
        type Ciphertext = S::Ciphertext;
        type Id = S::Id;
        type Epoch = S::Epoch;
        type Seq = S::Seq;
        type ConvoId = S::ConvoId;
    }
    ///State transition - sets the `ciphertext` field to Set
    pub struct SetCiphertext<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetCiphertext<S> {}
    impl<S: State> State for SetCiphertext<S> {
        type CreatedAt = S::CreatedAt;
        type Ciphertext = Set<members::ciphertext>;
        type Id = S::Id;
        type Epoch = S::Epoch;
        type Seq = S::Seq;
        type ConvoId = S::ConvoId;
    }
    ///State transition - sets the `id` field to Set
    pub struct SetId<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetId<S> {}
    impl<S: State> State for SetId<S> {
        type CreatedAt = S::CreatedAt;
        type Ciphertext = S::Ciphertext;
        type Id = Set<members::id>;
        type Epoch = S::Epoch;
        type Seq = S::Seq;
        type ConvoId = S::ConvoId;
    }
    ///State transition - sets the `epoch` field to Set
    pub struct SetEpoch<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetEpoch<S> {}
    impl<S: State> State for SetEpoch<S> {
        type CreatedAt = S::CreatedAt;
        type Ciphertext = S::Ciphertext;
        type Id = S::Id;
        type Epoch = Set<members::epoch>;
        type Seq = S::Seq;
        type ConvoId = S::ConvoId;
    }
    ///State transition - sets the `seq` field to Set
    pub struct SetSeq<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetSeq<S> {}
    impl<S: State> State for SetSeq<S> {
        type CreatedAt = S::CreatedAt;
        type Ciphertext = S::Ciphertext;
        type Id = S::Id;
        type Epoch = S::Epoch;
        type Seq = Set<members::seq>;
        type ConvoId = S::ConvoId;
    }
    ///State transition - sets the `convo_id` field to Set
    pub struct SetConvoId<S: State = Empty>(PhantomData<fn() -> S>);
    impl<S: State> sealed::Sealed for SetConvoId<S> {}
    impl<S: State> State for SetConvoId<S> {
        type CreatedAt = S::CreatedAt;
        type Ciphertext = S::Ciphertext;
        type Id = S::Id;
        type Epoch = S::Epoch;
        type Seq = S::Seq;
        type ConvoId = Set<members::convo_id>;
    }
    /// Marker types for field names
    #[allow(non_camel_case_types)]
    pub mod members {
        ///Marker type for the `created_at` field
        pub struct created_at(());
        ///Marker type for the `ciphertext` field
        pub struct ciphertext(());
        ///Marker type for the `id` field
        pub struct id(());
        ///Marker type for the `epoch` field
        pub struct epoch(());
        ///Marker type for the `seq` field
        pub struct seq(());
        ///Marker type for the `convo_id` field
        pub struct convo_id(());
    }
}

/// Builder for constructing an instance of this type
pub struct MessageViewBuilder<'a, S: message_view_state::State> {
    _phantom_state: ::core::marker::PhantomData<fn() -> S>,
    __unsafe_private_named: (
        ::core::option::Option<bytes::Bytes>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<jacquard_common::types::string::Datetime>,
        ::core::option::Option<i64>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<jacquard_common::CowStr<'a>>,
        ::core::option::Option<i64>,
    ),
    _phantom: ::core::marker::PhantomData<&'a ()>,
}

impl<'a> MessageView<'a> {
    /// Create a new builder for this type
    pub fn new() -> MessageViewBuilder<'a, message_view_state::Empty> {
        MessageViewBuilder::new()
    }
}

impl<'a> MessageViewBuilder<'a, message_view_state::Empty> {
    /// Create a new builder with all fields unset
    pub fn new() -> Self {
        MessageViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: (None, None, None, None, None, None, None),
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> MessageViewBuilder<'a, S>
where
    S: message_view_state::State,
    S::Ciphertext: message_view_state::IsUnset,
{
    /// Set the `ciphertext` field (required)
    pub fn ciphertext(
        mut self,
        value: impl Into<bytes::Bytes>,
    ) -> MessageViewBuilder<'a, message_view_state::SetCiphertext<S>> {
        self.__unsafe_private_named.0 = ::core::option::Option::Some(value.into());
        MessageViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> MessageViewBuilder<'a, S>
where
    S: message_view_state::State,
    S::ConvoId: message_view_state::IsUnset,
{
    /// Set the `convoId` field (required)
    pub fn convo_id(
        mut self,
        value: impl Into<jacquard_common::CowStr<'a>>,
    ) -> MessageViewBuilder<'a, message_view_state::SetConvoId<S>> {
        self.__unsafe_private_named.1 = ::core::option::Option::Some(value.into());
        MessageViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> MessageViewBuilder<'a, S>
where
    S: message_view_state::State,
    S::CreatedAt: message_view_state::IsUnset,
{
    /// Set the `createdAt` field (required)
    pub fn created_at(
        mut self,
        value: impl Into<jacquard_common::types::string::Datetime>,
    ) -> MessageViewBuilder<'a, message_view_state::SetCreatedAt<S>> {
        self.__unsafe_private_named.2 = ::core::option::Option::Some(value.into());
        MessageViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> MessageViewBuilder<'a, S>
where
    S: message_view_state::State,
    S::Epoch: message_view_state::IsUnset,
{
    /// Set the `epoch` field (required)
    pub fn epoch(
        mut self,
        value: impl Into<i64>,
    ) -> MessageViewBuilder<'a, message_view_state::SetEpoch<S>> {
        self.__unsafe_private_named.3 = ::core::option::Option::Some(value.into());
        MessageViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> MessageViewBuilder<'a, S>
where
    S: message_view_state::State,
    S::Id: message_view_state::IsUnset,
{
    /// Set the `id` field (required)
    pub fn id(
        mut self,
        value: impl Into<jacquard_common::CowStr<'a>>,
    ) -> MessageViewBuilder<'a, message_view_state::SetId<S>> {
        self.__unsafe_private_named.4 = ::core::option::Option::Some(value.into());
        MessageViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S: message_view_state::State> MessageViewBuilder<'a, S> {
    /// Set the `messageType` field (optional)
    pub fn message_type(mut self, value: impl Into<Option<jacquard_common::CowStr<'a>>>) -> Self {
        self.__unsafe_private_named.5 = value.into();
        self
    }
    /// Set the `messageType` field to an Option value (optional)
    pub fn maybe_message_type(mut self, value: Option<jacquard_common::CowStr<'a>>) -> Self {
        self.__unsafe_private_named.5 = value;
        self
    }
}

impl<'a, S> MessageViewBuilder<'a, S>
where
    S: message_view_state::State,
    S::Seq: message_view_state::IsUnset,
{
    /// Set the `seq` field (required)
    pub fn seq(
        mut self,
        value: impl Into<i64>,
    ) -> MessageViewBuilder<'a, message_view_state::SetSeq<S>> {
        self.__unsafe_private_named.6 = ::core::option::Option::Some(value.into());
        MessageViewBuilder {
            _phantom_state: ::core::marker::PhantomData,
            __unsafe_private_named: self.__unsafe_private_named,
            _phantom: ::core::marker::PhantomData,
        }
    }
}

impl<'a, S> MessageViewBuilder<'a, S>
where
    S: message_view_state::State,
    S::CreatedAt: message_view_state::IsSet,
    S::Ciphertext: message_view_state::IsSet,
    S::Id: message_view_state::IsSet,
    S::Epoch: message_view_state::IsSet,
    S::Seq: message_view_state::IsSet,
    S::ConvoId: message_view_state::IsSet,
{
    /// Build the final struct
    pub fn build(self) -> MessageView<'a> {
        MessageView {
            ciphertext: self.__unsafe_private_named.0.unwrap(),
            convo_id: self.__unsafe_private_named.1.unwrap(),
            created_at: self.__unsafe_private_named.2.unwrap(),
            epoch: self.__unsafe_private_named.3.unwrap(),
            id: self.__unsafe_private_named.4.unwrap(),
            message_type: self.__unsafe_private_named.5,
            seq: self.__unsafe_private_named.6.unwrap(),
            extra_data: Default::default(),
        }
    }
    /// Build the final struct with custom extra_data
    pub fn build_with_data(
        self,
        extra_data: std::collections::BTreeMap<
            jacquard_common::smol_str::SmolStr,
            jacquard_common::types::value::Data<'a>,
        >,
    ) -> MessageView<'a> {
        MessageView {
            ciphertext: self.__unsafe_private_named.0.unwrap(),
            convo_id: self.__unsafe_private_named.1.unwrap(),
            created_at: self.__unsafe_private_named.2.unwrap(),
            epoch: self.__unsafe_private_named.3.unwrap(),
            id: self.__unsafe_private_named.4.unwrap(),
            message_type: self.__unsafe_private_named.5,
            seq: self.__unsafe_private_named.6.unwrap(),
            extra_data: Some(extra_data),
        }
    }
}

impl<'a> ::jacquard_lexicon::schema::LexiconSchema for MessageView<'a> {
    fn nsid() -> &'static str {
        "blue.catbird.mlsChat.defs"
    }
    fn def_name() -> &'static str {
        "messageView"
    }
    fn lexicon_doc() -> ::jacquard_lexicon::lexicon::LexiconDoc<'static> {
        lexicon_doc_blue_catbird_mlsChat_defs()
    }
    fn validate(
        &self,
    ) -> ::std::result::Result<(), ::jacquard_lexicon::validation::ConstraintError> {
        {
            let value = &self.epoch;
            if *value < 0i64 {
                return Err(::jacquard_lexicon::validation::ConstraintError::Minimum {
                    path: ::jacquard_lexicon::validation::ValidationPath::from_field("epoch"),
                    min: 0i64,
                    actual: *value,
                });
            }
        }
        {
            let value = &self.seq;
            if *value < 0i64 {
                return Err(::jacquard_lexicon::validation::ConstraintError::Minimum {
                    path: ::jacquard_lexicon::validation::ValidationPath::from_field("seq"),
                    min: 0i64,
                    actual: *value,
                });
            }
        }
        Ok(())
    }
}
