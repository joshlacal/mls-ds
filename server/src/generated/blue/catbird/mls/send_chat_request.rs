// @generated - This file is generated by atrium-codegen. DO NOT EDIT.
//!Definitions for the `blue.catbird.mls.sendChatRequest` namespace.
pub const NSID: &str = "blue.catbird.mls.sendChatRequest";
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct InputData {
    ///Conversation ID if this is a group invite
    #[serde(skip_serializing_if = "core::option::Option::is_none")]
    pub group_id: core::option::Option<String>,
    ///Encrypted messages to hold until request accepted (max 5)
    #[serde(skip_serializing_if = "core::option::Option::is_none")]
    pub held_messages: core::option::Option<Vec<HeldMessage>>,
    ///If true, this is an invite to an existing group
    #[serde(skip_serializing_if = "core::option::Option::is_none")]
    pub is_group_invite: core::option::Option<bool>,
    ///Optional short plain-text preview message (not E2EE, max 200 chars)
    #[serde(skip_serializing_if = "core::option::Option::is_none")]
    pub preview_text: core::option::Option<String>,
    ///DID of the user to send chat request to
    pub recipient_did: String,
}
pub type Input = crate::types::Object<InputData>;
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct OutputData {
    ///Conversation ID if request was bypassed
    #[serde(skip_serializing_if = "core::option::Option::is_none")]
    pub convo_id: core::option::Option<String>,
    ///Request creation timestamp
    pub created_at: crate::types::string::Datetime,
    ///Request expiration timestamp
    pub expires_at: crate::types::string::Datetime,
    ///Unique request identifier (ULID)
    pub request_id: String,
    ///Request status (bypassed if social graph allows)
    pub status: String,
}
pub type Output = crate::types::Object<OutputData>;
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(tag = "error", content = "message")]
pub enum Error {
    BlockedByRecipient(Option<String>),
    RateLimited(Option<String>),
    RecipientNotFound(Option<String>),
    DuplicateRequest(Option<String>),
    SelfRequest(Option<String>),
}
impl std::fmt::Display for Error {
    fn fmt(&self, _f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            Error::BlockedByRecipient(msg) => {
                write!(_f, "BlockedByRecipient")?;
                if let Some(msg) = msg {
                    write!(_f, ": {msg}")?;
                }
            }
            Error::RateLimited(msg) => {
                write!(_f, "RateLimited")?;
                if let Some(msg) = msg {
                    write!(_f, ": {msg}")?;
                }
            }
            Error::RecipientNotFound(msg) => {
                write!(_f, "RecipientNotFound")?;
                if let Some(msg) = msg {
                    write!(_f, ": {msg}")?;
                }
            }
            Error::DuplicateRequest(msg) => {
                write!(_f, "DuplicateRequest")?;
                if let Some(msg) = msg {
                    write!(_f, ": {msg}")?;
                }
            }
            Error::SelfRequest(msg) => {
                write!(_f, "SelfRequest")?;
                if let Some(msg) = msg {
                    write!(_f, ": {msg}")?;
                }
            }
        }
        Ok(())
    }
}
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct HeldMessageData {
    ///MLS encrypted message ciphertext
    #[serde(with = "serde_bytes")]
    pub ciphertext: Vec<u8>,
    ///Optional ephemeral public key for forward secrecy
    #[serde(default)]
    #[serde(with = "serde_bytes")]
    #[serde(skip_serializing_if = "core::option::Option::is_none")]
    pub eph_pub_key: core::option::Option<Vec<u8>>,
    ///Padded ciphertext size (power of 2 buckets)
    pub padded_size: crate::types::BoundedU32<512u32, 10485760u32>,
}
pub type HeldMessage = crate::types::Object<HeldMessageData>;
