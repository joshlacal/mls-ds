// @generated - This file is generated by atrium-codegen. DO NOT EDIT.
//!Structs for ATP client, implements all HTTP APIs of XRPC.
///Client struct for the ATP service.
pub struct AtpServiceClient<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub service: Service<T>,
}
impl<T> AtpServiceClient<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub fn new(xrpc: T) -> Self {
        Self {
            service: Service::new(std::sync::Arc::new(xrpc)),
        }
    }
}
pub struct Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub blue: blue::Service<T>,
    pub(crate) _phantom: core::marker::PhantomData<T>,
}
pub mod blue {
    pub struct Service<T>
    where
        T: atrium_xrpc::XrpcClient + Send + Sync,
    {
        pub catbird: catbird::Service<T>,
        pub(crate) _phantom: core::marker::PhantomData<T>,
    }
    pub mod catbird {
        pub struct Service<T>
        where
            T: atrium_xrpc::XrpcClient + Send + Sync,
        {
            pub mls: mls::Service<T>,
            pub(crate) _phantom: core::marker::PhantomData<T>,
        }
        pub mod mls {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
                pub(crate) _phantom: core::marker::PhantomData<T>,
            }
        }
    }
}
impl<T> self::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            blue: blue::Service::new(std::sync::Arc::clone(&xrpc)),
            _phantom: core::marker::PhantomData,
        }
    }
}
impl<T> blue::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            catbird: blue::catbird::Service::new(std::sync::Arc::clone(&xrpc)),
            _phantom: core::marker::PhantomData,
        }
    }
}
impl<T> blue::catbird::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            mls: blue::catbird::mls::Service::new(std::sync::Arc::clone(&xrpc)),
            _phantom: core::marker::PhantomData,
        }
    }
}
impl<T> blue::catbird::mls::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            xrpc,
            _phantom: core::marker::PhantomData,
        }
    }
    ///Add members to an existing MLS conversation
    pub async fn add_members(
        &self,
        input: crate::blue::catbird::mls::add_members::Input,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::add_members::Output,
        crate::blue::catbird::mls::add_members::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::blue::catbird::mls::add_members::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Query Bluesky social graph to check block status between users. Returns block relationships relevant to MLS conversation membership. Server queries Bluesky PDS for current block state. Used before adding members to prevent blocked users from joining the same conversation.
    pub async fn check_blocks(
        &self,
        params: crate::blue::catbird::mls::check_blocks::Parameters,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::check_blocks::Output,
        crate::blue::catbird::mls::check_blocks::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::blue::catbird::mls::check_blocks::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Confirm successful or failed processing of Welcome message
    pub async fn confirm_welcome(
        &self,
        input: crate::blue::catbird::mls::confirm_welcome::Input,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::confirm_welcome::Output,
        crate::blue::catbird::mls::confirm_welcome::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::blue::catbird::mls::confirm_welcome::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Create a new MLS conversation
    pub async fn create_convo(
        &self,
        input: crate::blue::catbird::mls::create_convo::Input,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::create_convo::Output,
        crate::blue::catbird::mls::create_convo::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::blue::catbird::mls::create_convo::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Demote an admin to regular member. Caller must be an admin (unless demoting self). Cannot demote the last admin. Server enforces authorization, updates DB, and logs action.
    pub async fn demote_admin(
        &self,
        input: crate::blue::catbird::mls::demote_admin::Input,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::demote_admin::Output,
        crate::blue::catbird::mls::demote_admin::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::blue::catbird::mls::demote_admin::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Query moderation and admin action statistics. Returns aggregate counts of reports, removals, and block conflicts resolved. Used for App Store review to demonstrate active moderation capabilities. Only accessible to conversation admins.
    pub async fn get_admin_stats(
        &self,
        params: crate::blue::catbird::mls::get_admin_stats::Parameters,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::get_admin_stats::Output,
        crate::blue::catbird::mls::get_admin_stats::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::blue::catbird::mls::get_admin_stats::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Query block status for all members of a conversation. Returns any block relationships between current members. Useful for admins to identify and resolve block conflicts.
    pub async fn get_block_status(
        &self,
        params: crate::blue::catbird::mls::get_block_status::Parameters,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::get_block_status::Output,
        crate::blue::catbird::mls::get_block_status::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::blue::catbird::mls::get_block_status::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Retrieve MLS commit messages for a conversation within an epoch range
    pub async fn get_commits(
        &self,
        params: crate::blue::catbird::mls::get_commits::Parameters,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::get_commits::Output,
        crate::blue::catbird::mls::get_commits::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::blue::catbird::mls::get_commits::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Query to fetch user's MLS conversations
    pub async fn get_convos(
        &self,
        params: crate::blue::catbird::mls::get_convos::Parameters,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::get_convos::Output,
        crate::blue::catbird::mls::get_convos::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::blue::catbird::mls::get_convos::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get the current epoch for an MLS conversation
    pub async fn get_epoch(
        &self,
        params: crate::blue::catbird::mls::get_epoch::Parameters,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::get_epoch::Output,
        crate::blue::catbird::mls::get_epoch::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::blue::catbird::mls::get_epoch::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get key package inventory statistics for the authenticated user to determine when replenishment is needed
    pub async fn get_key_package_stats(
        &self,
        params: crate::blue::catbird::mls::get_key_package_stats::Parameters,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::get_key_package_stats::Output,
        crate::blue::catbird::mls::get_key_package_stats::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::blue::catbird::mls::get_key_package_stats::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Retrieve key packages for one or more DIDs to add them to conversations
    pub async fn get_key_packages(
        &self,
        params: crate::blue::catbird::mls::get_key_packages::Parameters,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::get_key_packages::Output,
        crate::blue::catbird::mls::get_key_packages::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::blue::catbird::mls::get_key_packages::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Retrieve messages from an MLS conversation. Messages are GUARANTEED to be returned in MLS sequential order (epoch ASC, seq ASC). Clients MUST process messages in this order for proper MLS decryption.
    pub async fn get_messages(
        &self,
        params: crate::blue::catbird::mls::get_messages::Parameters,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::get_messages::Output,
        crate::blue::catbird::mls::get_messages::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::blue::catbird::mls::get_messages::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Retrieve reports for a conversation. Admin-only endpoint. Returns encrypted report blobs that admins must decrypt locally using MLS group key.
    pub async fn get_reports(
        &self,
        params: crate::blue::catbird::mls::get_reports::Parameters,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::get_reports::Output,
        crate::blue::catbird::mls::get_reports::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::blue::catbird::mls::get_reports::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Retrieve the Welcome message for a conversation the user is a member of
    pub async fn get_welcome(
        &self,
        params: crate::blue::catbird::mls::get_welcome::Parameters,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::get_welcome::Output,
        crate::blue::catbird::mls::get_welcome::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::blue::catbird::mls::get_welcome::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Client notifies server when a Bluesky block is created or removed that affects MLS conversations. Server checks if both users are in any conversations together and notifies admins of conflicts. Enables reactive moderation when blocks occur after users have already joined conversations.
    pub async fn handle_block_change(
        &self,
        input: crate::blue::catbird::mls::handle_block_change::Input,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::handle_block_change::Output,
        crate::blue::catbird::mls::handle_block_change::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::blue::catbird::mls::handle_block_change::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Leave an MLS conversation
    pub async fn leave_convo(
        &self,
        input: crate::blue::catbird::mls::leave_convo::Input,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::leave_convo::Output,
        crate::blue::catbird::mls::leave_convo::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::blue::catbird::mls::leave_convo::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Promote a conversation member to admin. Caller must be an existing admin. Server enforces authorization, then updates DB and logs action. Caller should also send an encrypted adminRoster update via sendMessage.
    pub async fn promote_admin(
        &self,
        input: crate::blue::catbird::mls::promote_admin::Input,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::promote_admin::Output,
        crate::blue::catbird::mls::promote_admin::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::blue::catbird::mls::promote_admin::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Publish an MLS key package to enable others to add you to conversations
    pub async fn publish_key_package(
        &self,
        input: crate::blue::catbird::mls::publish_key_package::Input,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::publish_key_package::Output,
        crate::blue::catbird::mls::publish_key_package::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::blue::catbird::mls::publish_key_package::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Publish multiple MLS key packages in a single batch request (up to 100 packages). More efficient than individual uploads for replenishing key package pools.
    pub async fn publish_key_packages(
        &self,
        input: crate::blue::catbird::mls::publish_key_packages::Input,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::publish_key_packages::Output,
        crate::blue::catbird::mls::publish_key_packages::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::blue::catbird::mls::publish_key_packages::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Register a new device with the MLS server. Each device gets a unique MLS identity (did:plc:user#device-uuid). Server automatically adds device to user's existing conversations. Returns device credentials for local storage.
    pub async fn register_device(
        &self,
        input: crate::blue::catbird::mls::register_device::Input,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::register_device::Output,
        crate::blue::catbird::mls::register_device::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::blue::catbird::mls::register_device::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Remove a member from the conversation. Admin-only operation. Server authorizes, soft-deletes membership (sets left_at), and logs action. The admin client must issue an MLS Remove commit via the standard MLS flow to cryptographically remove the member and advance the epoch.
    pub async fn remove_member(
        &self,
        input: crate::blue::catbird::mls::remove_member::Input,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::remove_member::Output,
        crate::blue::catbird::mls::remove_member::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::blue::catbird::mls::remove_member::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Submit an encrypted report about a conversation member to admins. Report content is E2EE and only admins can decrypt. Server stores metadata and routes to admins. Any member can report; cannot report self.
    pub async fn report_member(
        &self,
        input: crate::blue::catbird::mls::report_member::Input,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::report_member::Output,
        crate::blue::catbird::mls::report_member::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::blue::catbird::mls::report_member::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Submit rejoin request with fresh KeyPackage after state loss (e.g., app reinstall, device change)
    pub async fn request_rejoin(
        &self,
        input: crate::blue::catbird::mls::request_rejoin::Input,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::request_rejoin::Output,
        crate::blue::catbird::mls::request_rejoin::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::blue::catbird::mls::request_rejoin::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Mark a report as resolved with the action taken. Admin-only operation. Records resolution in audit trail.
    pub async fn resolve_report(
        &self,
        input: crate::blue::catbird::mls::resolve_report::Input,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::resolve_report::Output,
        crate::blue::catbird::mls::resolve_report::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::blue::catbird::mls::resolve_report::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Send an encrypted message to an MLS conversation
    pub async fn send_message(
        &self,
        input: crate::blue::catbird::mls::send_message::Input,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::send_message::Output,
        crate::blue::catbird::mls::send_message::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::blue::catbird::mls::send_message::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Subscribe to live events (new messages, reactions, etc.) via Server-Sent Events in conversations involving the authenticated user
    pub async fn stream_convo_events(
        &self,
        params: crate::blue::catbird::mls::stream_convo_events::Parameters,
    ) -> atrium_xrpc::Result<
        crate::blue::catbird::mls::stream_convo_events::Output,
        crate::blue::catbird::mls::stream_convo_events::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::blue::catbird::mls::stream_convo_events::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
}
