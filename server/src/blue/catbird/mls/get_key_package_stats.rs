// @generated - This file is generated by atrium-codegen. DO NOT EDIT.
//!Definitions for the `blue.catbird.mls.getKeyPackageStats` namespace.
pub const NSID: &str = "blue.catbird.mls.getKeyPackageStats";
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct ParametersData {
    ///Filter by specific cipher suite
    #[serde(skip_serializing_if = "core::option::Option::is_none")]
    pub cipher_suite: core::option::Option<String>,
    ///DID to fetch stats for (defaults to authenticated user)
    #[serde(skip_serializing_if = "core::option::Option::is_none")]
    pub did: core::option::Option<crate::types::string::Did>,
}
pub type Parameters = crate::types::Object<ParametersData>;
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct OutputData {
    ///Number of unconsumed key packages available
    pub available: usize,
    ///Breakdown by cipher suite
    #[serde(skip_serializing_if = "core::option::Option::is_none")]
    pub by_cipher_suite: core::option::Option<Vec<CipherSuiteStats>>,
    ///True if available < threshold
    pub needs_replenish: bool,
    ///Human-readable time until oldest key package expires (e.g., '23d 4h')
    #[serde(skip_serializing_if = "core::option::Option::is_none")]
    pub oldest_expires_in: core::option::Option<String>,
    ///Recommended minimum inventory threshold
    pub threshold: core::num::NonZeroU64,
}
pub type Output = crate::types::Object<OutputData>;
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(tag = "error", content = "message")]
pub enum Error {
    ///The provided DID is invalid
    InvalidDid(Option<String>),
}
impl std::fmt::Display for Error {
    fn fmt(&self, _f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            Error::InvalidDid(msg) => {
                write!(_f, "InvalidDid")?;
                if let Some(msg) = msg {
                    write!(_f, ": {msg}")?;
                }
            }
        }
        Ok(())
    }
}
///Key package statistics for a specific cipher suite
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct CipherSuiteStatsData {
    ///Available key packages for this suite
    pub available: usize,
    ///Cipher suite name
    pub cipher_suite: String,
    ///Total consumed key packages for this suite
    #[serde(skip_serializing_if = "core::option::Option::is_none")]
    pub consumed: core::option::Option<usize>,
}
pub type CipherSuiteStats = crate::types::Object<CipherSuiteStatsData>;
