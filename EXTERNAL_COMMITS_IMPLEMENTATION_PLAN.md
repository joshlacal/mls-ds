# External Commits Implementation Plan

**Date**: 2025-11-19  
**Status**: Ready for Implementation  
**Estimated Time**: 3-5 days  
**Impact**: Eliminates 2-5 second rejoin latency, removes dependency on other clients being online

---

## Executive Summary

### Current State: Request-and-Wait
- Client needs to rejoin → uploads KeyPackage → waits for another device to approve
- Requires another client to be online and generate Welcome message
- 2-5 second latency in best case, indefinite wait if no other clients online
- Works but creates UX friction

### Proposed: Instant External Commits
- Client needs to rejoin → fetches GroupInfo → generates external commit → instant rejoin
- No dependency on other clients
- <500ms latency (just server roundtrip)
- Standard MLS RFC 9420 feature, fully supported by OpenMLS 0.6+

---

## Architecture Overview

### What is an External Commit?

```
Traditional Join (Current):
┌─────────┐         ┌─────────┐         ┌─────────┐
│ Client  │         │ Server  │         │ Other   │
│ (Lost)  │         │         │         │ Client  │
└────┬────┘         └────┬────┘         └────┬────┘
     │                   │                   │
     │─uploadKeyPackage─>│                   │
     │                   │─requestAddMember─>│
     │                   │                   │  ⏱️ WAIT
     │                   │<─generateWelcome──│
     │<──getWelcome()────│                   │
     │                   │                   │
```

```
External Commit (Proposed):
┌─────────┐         ┌─────────┐
│ Client  │         │ Server  │
│ (Lost)  │         │         │
└────┬────┘         └────┬────┘
     │                   │
     │─getGroupInfo()───>│
     │<─GroupInfo────────│
     │                   │
     │ (generate commit  │
     │  locally)         │
     │                   │
     │─externalCommit──>│  ⚡ INSTANT
     │<─success──────────│
     │                   │
```

### Security Model

**External commits maintain ALL MLS security properties:**
- ✅ **Forward Secrecy**: Rejoining device gets NEW keys, can't decrypt past messages
- ✅ **Post-Compromise Security**: Future messages protected even if past keys leaked
- ✅ **Authentication**: GroupInfo is cryptographically signed, can't be forged
- ✅ **Authorization**: Server validates rejoiner was previous member

**What's different from internal commits:**
- Generated by non-member (hence "external")
- Requires `GroupInfo` (public group state snapshot)
- Can only be used by previously authorized members (server policy)

---

## Implementation Phases

### Phase 0: Upgrade OpenMLS (Day 0)

**Decision: Use OpenMLS 0.7.1 on both server AND FFI client**

Reasoning:
- Consistency across codebase (easier debugging)
- Both need external commit support
- Server doesn't need bleeding-edge features that require nightly Rust
- Stable Rust (1.90.0) is sufficient for production server

**Note on Nightly Rust:**
- Only use nightly on FFI client if you need specific Swift/C interop features
- Server should stay on stable for production reliability
- If FFI already uses nightly (for other reasons), that's fine—keep it

---

### Phase 1: GroupInfo Export & Storage (Day 1)

**Goal**: Server can export and cache GroupInfo for each conversation

#### 1.1 Database Schema Changes

```sql
-- Add GroupInfo storage to conversations table
ALTER TABLE conversations
ADD COLUMN group_info BYTEA,
ADD COLUMN group_info_updated_at TIMESTAMPTZ,
ADD COLUMN group_info_epoch INTEGER;

-- Index for efficient lookups
CREATE INDEX idx_conversations_group_info_epoch 
ON conversations(id, group_info_epoch);
```

#### 1.2 GroupInfo Generation Logic

**Location**: `server/src/handlers/mod.rs` (or new file `group_info.rs`)

**Pseudo-code:**
```rust
/// Generate GroupInfo from current conversation state
pub async fn generate_group_info(
    pool: &PgPool,
    convo_id: &str,
) -> Result<Vec<u8>> {
    // 1. Fetch conversation's current epoch and tree state
    let convo = get_conversation(pool, convo_id).await?;
    
    // 2. Load MLS group state from storage
    let mls_group = load_mls_group_state(pool, convo_id).await?;
    
    // 3. Export GroupInfo (OpenMLS built-in method)
    let group_info = mls_group.export_group_info(
        &crypto_provider,
        &signer,
        true, // with_ratchet_tree
    )?;
    
    // 4. Serialize for storage
    let group_info_bytes = group_info.tls_serialize_detached()?;
    
    // 5. Cache in database
    sqlx::query!(
        "UPDATE conversations 
         SET group_info = $1, 
             group_info_updated_at = NOW(),
             group_info_epoch = $2
         WHERE id = $3",
        group_info_bytes,
        convo.current_epoch,
        convo_id
    )
    .execute(pool)
    .await?;
    
    Ok(group_info_bytes)
}
```

#### 1.3 Update Commit Handlers

**Every handler that changes group state must update GroupInfo:**

Files to modify:
- `handlers/add_members.rs`
- `handlers/remove_member.rs`
- `handlers/leave_convo.rs`
- Any handler that calls `mls_group.commit()`

**Pattern:**
```rust
// After processing commit
let commit_result = mls_group.commit(&crypto_provider, &signer)?;

// ... existing code to store commit ...

// NEW: Regenerate and cache GroupInfo
generate_group_info(pool, &input.convo_id).await?;
```

---

### Phase 2: Client External Commit API (Day 2-3)

#### 2.1 New Lexicon: `getGroupInfo`

**File**: `lexicon/blue/catbird/mls/getGroupInfo.json`

```json
{
  "lexicon": 1,
  "id": "blue.catbird.mls.getGroupInfo",
  "defs": {
    "main": {
      "type": "query",
      "description": "Fetch GroupInfo for external commit. Only available to current/past members.",
      "parameters": {
        "type": "params",
        "required": ["convoId"],
        "properties": {
          "convoId": {
            "type": "string",
            "description": "Conversation ID"
          }
        }
      },
      "output": {
        "encoding": "application/json",
        "schema": {
          "type": "object",
          "required": ["groupInfo", "epoch"],
          "properties": {
            "groupInfo": {
              "type": "string",
              "description": "Base64-encoded TLS-serialized GroupInfo"
            },
            "epoch": {
              "type": "integer",
              "description": "Current epoch number"
            },
            "expiresAt": {
              "type": "string",
              "format": "datetime",
              "description": "When GroupInfo becomes stale (5 minutes)"
            }
          }
        }
      },
      "errors": [
        {
          "name": "NotFound",
          "description": "Conversation not found"
        },
        {
          "name": "Unauthorized",
          "description": "Not a current or past member"
        },
        {
          "name": "GroupInfoUnavailable",
          "description": "GroupInfo not yet generated for this conversation"
        }
      ]
    }
  }
}
```

#### 2.2 Handler Implementation

**File**: `server/src/handlers/get_group_info.rs`

```rust
use axum::{extract::State, Json};
use crate::{
    auth::AuthUser,
    error::{Error, Result},
    generated::blue::catbird::mls::get_group_info::{Input, Output},
    models::AppState,
};

pub async fn handle(
    State(state): State<AppState>,
    auth: AuthUser,
    input: Input,
) -> Result<Json<Output>> {
    let pool = &state.pool;
    let did = &auth.did;
    
    // 1. Check authorization: must be current OR past member
    let member_check = sqlx::query!(
        "SELECT m.user_did, m.left_at 
         FROM members m
         WHERE m.convo_id = $1 AND m.user_did = $2
         LIMIT 1",
        input.convo_id,
        did
    )
    .fetch_optional(pool)
    .await?;
    
    let member = member_check.ok_or(Error::Unauthorized(
        "Not a member of this conversation".into()
    ))?;
    
    // 2. Allow if currently in group OR left recently (within 30 days)
    if let Some(left_at) = member.left_at {
        let days_since_left = (chrono::Utc::now() - left_at).num_days();
        if days_since_left > 30 {
            return Err(Error::Unauthorized(
                "Membership expired (left more than 30 days ago)".into()
            ));
        }
    }
    
    // 3. Fetch cached GroupInfo
    let row = sqlx::query!(
        "SELECT group_info, group_info_epoch, group_info_updated_at
         FROM conversations
         WHERE id = $1",
        input.convo_id
    )
    .fetch_one(pool)
    .await?;
    
    let group_info_bytes = row.group_info.ok_or(Error::InternalError(
        "GroupInfo not available for this conversation".into()
    ))?;
    
    let epoch = row.group_info_epoch.ok_or(Error::InternalError(
        "Missing epoch information".into()
    ))?;
    
    // 4. Check freshness (regenerate if > 5 minutes old)
    if let Some(updated_at) = row.group_info_updated_at {
        let age = chrono::Utc::now() - updated_at;
        if age.num_minutes() > 5 {
            // Regenerate fresh GroupInfo
            let fresh_info = generate_group_info(pool, &input.convo_id).await?;
            return Ok(Json(Output {
                group_info: base64::encode(fresh_info),
                epoch,
                expires_at: Some((chrono::Utc::now() + chrono::Duration::minutes(5))
                    .to_rfc3339()),
            }));
        }
    }
    
    // 5. Return cached GroupInfo
    Ok(Json(Output {
        group_info: base64::encode(group_info_bytes),
        epoch,
        expires_at: row.group_info_updated_at.map(|t| {
            (t + chrono::Duration::minutes(5)).to_rfc3339()
        }),
    }))
}
```

#### 2.3 Register Handler

**File**: `server/src/handlers/mod.rs`

```rust
pub mod get_group_info;

// In router setup:
.route("/xrpc/blue.catbird.mls.getGroupInfo", 
    get(get_group_info::handle))
```

---

### Phase 3: External Commit Processing (Day 3-4)

#### 3.1 New Lexicon: `processExternalCommit`

**File**: `lexicon/blue/catbird/mls/processExternalCommit.json`

```json
{
  "lexicon": 1,
  "id": "blue.catbird.mls.processExternalCommit",
  "defs": {
    "main": {
      "type": "procedure",
      "description": "Submit an external commit to rejoin a group instantly",
      "input": {
        "encoding": "application/json",
        "schema": {
          "type": "object",
          "required": ["convoId", "externalCommit"],
          "properties": {
            "convoId": {
              "type": "string"
            },
            "externalCommit": {
              "type": "string",
              "description": "Base64-encoded TLS-serialized MlsMessageOut"
            }
          }
        }
      },
      "output": {
        "encoding": "application/json",
        "schema": {
          "type": "object",
          "required": ["success", "epoch"],
          "properties": {
            "success": {
              "type": "boolean"
            },
            "epoch": {
              "type": "integer",
              "description": "New epoch after commit applied"
            },
            "rejoinedAt": {
              "type": "string",
              "format": "datetime"
            }
          }
        }
      },
      "errors": [
        {
          "name": "InvalidCommit",
          "description": "External commit validation failed"
        },
        {
          "name": "EpochMismatch",
          "description": "GroupInfo epoch doesn't match current state"
        },
        {
          "name": "Unauthorized",
          "description": "Not authorized to rejoin this conversation"
        }
      ]
    }
  }
}
```

#### 3.2 Handler Implementation

**File**: `server/src/handlers/process_external_commit.rs`

```rust
use axum::{extract::State, Json};
use openmls::prelude::*;
use crate::{
    auth::AuthUser,
    error::{Error, Result},
    generated::blue::catbird::mls::process_external_commit::{Input, Output},
    models::AppState,
};

pub async fn handle(
    State(state): State<AppState>,
    auth: AuthUser,
    input: Input,
) -> Result<Json<Output>> {
    let pool = &state.pool;
    let did = &auth.did;
    
    // 1. Verify authorization (same as getGroupInfo)
    verify_can_rejoin(pool, &input.convo_id, did).await?;
    
    // 2. Decode external commit
    let commit_bytes = base64::decode(&input.external_commit)
        .map_err(|e| Error::BadRequest(format!("Invalid base64: {}", e)))?;
    
    let mls_message = MlsMessageIn::tls_deserialize_exact(&commit_bytes)
        .map_err(|e| Error::BadRequest(format!("Invalid MLS message: {}", e)))?;
    
    // 3. Load current group state
    let mut mls_group = load_mls_group_state(pool, &input.convo_id).await?;
    let current_epoch = mls_group.epoch().as_u64();
    
    // 4. Validate external commit
    let processed_message = mls_group
        .process_message(&crypto_provider, mls_message)
        .map_err(|e| Error::InvalidCommit(format!("Processing failed: {}", e)))?;
    
    // 5. Extract staged commit
    let staged_commit = match processed_message.into_content() {
        ProcessedMessageContent::StagedCommitMessage(commit) => commit,
        _ => return Err(Error::BadRequest("Not a valid commit message".into())),
    };
    
    // 6. Verify it's an external commit adding the right user
    let new_member_did = extract_added_member_did(&staged_commit)?;
    if !new_member_did.starts_with(&format!("{}#", did)) {
        return Err(Error::Unauthorized(
            "External commit must add your own device".into()
        ));
    }
    
    // 7. Merge staged commit
    mls_group
        .merge_staged_commit(&crypto_provider, *staged_commit)
        .map_err(|e| Error::InternalError(format!("Merge failed: {}", e)))?;
    
    let new_epoch = mls_group.epoch().as_u64();
    
    // 8. Persist updated group state
    save_mls_group_state(pool, &input.convo_id, &mls_group).await?;
    
    // 9. Update members table
    let now = chrono::Utc::now();
    sqlx::query!(
        "INSERT INTO members (convo_id, member_mls_did, user_did, device_id, joined_at)
         VALUES ($1, $2, $3, $4, $5)
         ON CONFLICT (convo_id, member_mls_did) 
         DO UPDATE SET left_at = NULL, joined_at = $5",
        input.convo_id,
        new_member_did,
        did,
        extract_device_id(&new_member_did),
        now
    )
    .execute(pool)
    .await?;
    
    // 10. Regenerate GroupInfo for next rejoiner
    generate_group_info(pool, &input.convo_id).await?;
    
    // 11. Fanout commit to other members
    fanout_commit_to_members(pool, &input.convo_id, &commit_bytes).await?;
    
    Ok(Json(Output {
        success: true,
        epoch: new_epoch as i32,
        rejoined_at: Some(now.to_rfc3339()),
    }))
}

/// Extract DID of newly added member from staged commit
fn extract_added_member_did(commit: &StagedCommit) -> Result<String> {
    for proposal in commit.add_proposals() {
        if let Some(credential) = proposal.key_package().leaf_node().credential() {
            if let CredentialType::Basic(basic) = credential.credential_type() {
                let identity = String::from_utf8(basic.identity().to_vec())
                    .map_err(|e| Error::InvalidCommit(format!("Invalid identity: {}", e)))?;
                return Ok(identity);
            }
        }
    }
    Err(Error::InvalidCommit("No member added in commit".into()))
}
```

---

### Phase 4: Client Integration Guide (Day 4-5)

#### 4.1 Swift Client Flow (Pseudocode)

```swift
// In your MLS client wrapper

/// Rejoin conversation using external commit (instant, no waiting)
func rejoinConversationInstant(convoId: String) async throws {
    // 1. Fetch GroupInfo from server
    let response = try await client.getGroupInfo(convoId: convoId)
    let groupInfoBytes = Data(base64Encoded: response.groupInfo)!
    
    // 2. Deserialize GroupInfo
    let groupInfo = try GroupInfo(bytes: groupInfoBytes)
    
    // 3. Join group via external commit (OpenMLS FFI)
    let (mlsGroup, externalCommit) = try MlsGroup.joinByExternalCommit(
        groupInfo: groupInfo,
        credential: myCredential,
        signerKeyPair: mySignerKeyPair,
        cryptoProvider: rustCrypto
    )
    
    // 4. Serialize external commit for server
    let commitBytes = try externalCommit.tlsSerialize()
    let commitBase64 = commitBytes.base64EncodedString()
    
    // 5. Submit to server
    let result = try await client.processExternalCommit(
        convoId: convoId,
        externalCommit: commitBase64
    )
    
    // 6. Save locally
    try mlsGroup.save(to: localGroupStorage(convoId))
    
    print("✅ Rejoined instantly! New epoch: \(result.epoch)")
}
```

#### 4.2 Migration Path

**Support both flows during transition:**

```swift
enum RejoinStrategy {
    case legacy    // Upload KeyPackage, wait for Welcome
    case instant   // External commit (requires server v2)
}

func rejoinConversation(
    convoId: String, 
    strategy: RejoinStrategy = .instant
) async throws {
    switch strategy {
    case .legacy:
        try await rejoinConversationLegacy(convoId: convoId)
    case .instant:
        try await rejoinConversationInstant(convoId: convoId)
    }
}
```

---

## OpenMLS Version Upgrade

### Current: 0.6.0 → Target: 0.7.1

#### Changes in `server/Cargo.toml`:

```toml
[dependencies]
# MLS - UPDATED TO 0.7.1
openmls = "0.7.1"
openmls_traits = "0.3"
openmls_basic_credential = "0.3"
openmls_rust_crypto = "0.3"
```

#### Rust Toolchain Decision:

**Server:** Use stable Rust (1.90.0 or latest stable)
- Production stability is priority
- OpenMLS 0.7.1 works fine on stable
- Avoid nightly unless you have specific reason

**FFI Client:** Can use nightly Rust IF needed for Swift interop
- Only if `#![feature(xyz)]` is required
- Otherwise stick to stable for consistency

#### Breaking Changes in 0.7.1:

Check migration guide when upgrading:
```bash
cargo update -p openmls
cargo build  # May have minor API changes
```

**Common changes:**
- Some method signatures updated (check compiler errors)
- New methods available (`join_by_external_commit`, etc.)
- Better error types

---

## Security & Policy Considerations

### 1. Who Can Use External Commits?

**Recommended Policy:**
```rust
async fn verify_can_rejoin(pool: &PgPool, convo_id: &str, did: &str) -> Result<()> {
    let member = sqlx::query!(
        "SELECT left_at, banned_at 
         FROM members 
         WHERE convo_id = $1 AND user_did = $2",
        convo_id,
        did
    )
    .fetch_optional(pool)
    .await?;
    
    let member = member.ok_or(Error::Unauthorized("Never a member"))?;
    
    // Reject if banned
    if member.banned_at.is_some() {
        return Err(Error::Unauthorized("User is banned"));
    }
    
    // Reject if left > 30 days ago
    if let Some(left_at) = member.left_at {
        if (Utc::now() - left_at).num_days() > 30 {
            return Err(Error::Unauthorized("Membership expired"));
        }
    }
    
    Ok(())
}
```

### 2. Rate Limiting

**Prevent abuse:**
```rust
// In middleware
let rejoin_key = format!("rejoin:{}:{}", did, convo_id);
rate_limiter.check_rate_limit(&rejoin_key, 5, Duration::hours(1))?;
```

**Limits:**
- 5 external commits per conversation per hour per user
- Prevents spammy rejoin attacks

### 3. Audit Logging

```rust
// After successful external commit
audit_log(
    "external_commit_processed",
    json!({
        "convo_id": convo_id,
        "user_did": did,
        "device_did": new_member_did,
        "old_epoch": current_epoch,
        "new_epoch": new_epoch,
    })
);
```

---

## Testing Strategy

### Unit Tests

**File**: `server/src/handlers/process_external_commit.rs`

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_valid_external_commit() {
        // Setup: Create conversation, user leaves
        // Action: Submit external commit
        // Assert: User successfully rejoined
    }

    #[tokio::test]
    async fn test_unauthorized_external_commit() {
        // Setup: User never was member
        // Action: Try external commit
        // Assert: Returns Unauthorized error
    }

    #[tokio::test]
    async fn test_expired_membership() {
        // Setup: User left 31 days ago
        // Action: Try external commit
        // Assert: Returns Unauthorized error
    }

    #[tokio::test]
    async fn test_epoch_mismatch() {
        // Setup: Fetch stale GroupInfo
        // Action: Submit external commit
        // Assert: Returns EpochMismatch error
    }
}
```

### Integration Tests

**File**: `tests/external_commit_flow.rs`

```rust
#[tokio::test]
async fn test_instant_rejoin_flow() {
    // 1. Create conversation with Alice and Bob
    // 2. Alice's device loses state
    // 3. Alice fetches GroupInfo
    // 4. Alice generates external commit
    // 5. Alice submits to server
    // 6. Verify Alice rejoined instantly
    // 7. Verify Bob receives commit notification
    // 8. Verify group state is consistent
}
```

---

## Rollout Plan

### Week 1: Server Implementation
- Day 1: Database schema + GroupInfo generation
- Day 2: `getGroupInfo` handler
- Day 3-4: `processExternalCommit` handler
- Day 5: Testing and bug fixes

### Week 2: Client Integration
- Day 1-2: FFI wrapper for external commits
- Day 3: Swift integration
- Day 4: Testing with production data
- Day 5: Gradual rollout (10% → 50% → 100%)

### Monitoring

**Key Metrics:**
- External commit success rate (target: >99%)
- Rejoin latency (target: <500ms)
- Error rate (target: <0.1%)
- Fallback to legacy rejoin (track for comparison)

**Alerts:**
- External commit failure rate > 1%
- Epoch mismatch rate > 0.5%
- Average latency > 1 second

---

## Backwards Compatibility

### Support Both Flows

Keep `requestRejoin` handler active for:
- Older clients that haven't updated
- Fallback if external commit fails
- A/B testing

**Auto-detection in client:**
```swift
func rejoin(convoId: String) async throws {
    do {
        // Try instant external commit first
        try await rejoinConversationInstant(convoId: convoId)
    } catch {
        // Fall back to legacy flow
        logger.warning("External commit failed, using legacy rejoin")
        try await rejoinConversationLegacy(convoId: convoId)
    }
}
```

---

## FAQ

**Q: Can malicious users use this to join conversations they shouldn't?**  
A: No. The server validates they were previously a member and haven't been banned. GroupInfo is signed, can't be forged.

**Q: What if GroupInfo becomes stale during rejoin?**  
A: Client will get `EpochMismatch` error. They refetch fresh GroupInfo and retry. Usually succeeds on second attempt.

**Q: Does this break forward secrecy?**  
A: No. The rejoining device gets NEW keys and can't decrypt past messages (same as traditional rejoin).

**Q: Can we skip GroupInfo caching and generate on-demand?**  
A: Possible but slower. Caching optimizes for common case (multiple devices rejoining). 5-minute TTL keeps it fresh.

**Q: What about offline scenarios?**  
A: External commits require server interaction (fetch GroupInfo, submit commit). For true offline, you'd need Welcome messages cached locally—but that's a different feature.

---

## Success Criteria

✅ **Functional Requirements:**
- [ ] `getGroupInfo` returns valid GroupInfo for authorized users
- [ ] `processExternalCommit` validates and applies external commits
- [ ] Rejoin latency < 500ms (down from 2-5 seconds)
- [ ] No dependency on other clients being online

✅ **Security Requirements:**
- [ ] Only past/current members can fetch GroupInfo
- [ ] Banned users cannot rejoin
- [ ] Expired memberships (>30 days) rejected
- [ ] All MLS security properties maintained

✅ **Operational Requirements:**
- [ ] 99%+ success rate in production
- [ ] Monitoring and alerts active
- [ ] Fallback to legacy rejoin works
- [ ] Documentation complete

---

## Next Steps

1. **Review this plan** with team
2. **Upgrade OpenMLS** to 0.7.1 on server
3. **Start Phase 1** (GroupInfo export)
4. **Daily standups** to track progress
5. **Update** this doc as you learn

---

**Questions?** Add them to this doc or create GitHub issues tagged `external-commits`.
