# Epoch Desynchronization Bug - Root Cause Analysis

## Executive Summary

The epoch desynchronization bug is caused by a **client-side trust issue** where the Swift application layer incorrectly trusts the server's reported epoch over its own MLS FFI layer's authoritative state, combined with a **server-side validation gap** that accepts messages with mismatched epochs.

---

## Timeline of the Bug

### Step 1: Group Creation (Correct)
```
User A (Swift App)  ‚Üí  MLS FFI  ‚Üí  OpenMLS
```

1. Client creates MLS group locally
2. FFI initializes group at **Epoch 0**
3. Log: `[MLS-CONTEXT] MLS group created successfully, Exporting epoch 0 secret...`

‚úÖ **State: App Layer = Epoch 0, FFI = Epoch 0**

---

### Step 2: Adding Member (Divergence Begins)
```
User A (Swift App)  ‚Üí  MLS FFI  ‚Üí  OpenMLS
```

1. Client calls `addMembers()` to add User B
2. **FFI correctly advances to Epoch 1** (MLS protocol requirement)
3. FFI generates:
   - `Commit` message (to update group state)
   - `Welcome` message (encrypted invitation for User B)
4. Log: `[MLS-FFI] ‚úÖ Group advanced to epoch 1`

‚úÖ **State: FFI = Epoch 1** (correct)
‚ö†Ô∏è  **State: App Layer = still thinks Epoch 0** (stale)

---

### Step 3: Server API Call (The Critical Mistake)
```
User A (Swift App)  ‚Üí  POST /xrpc/blue.catbird.mls.createConvo  ‚Üí  Server
                    ‚Üê  Response: { "epoch": 0, "groupId": "..." }
```

**What Happens on Server:**
```rust
// server/src/handlers/create_convo.rs:420
Ok(Json(ConvoView::from(ConvoViewData {
    group_id: convo_id,
    creator: creator_did,
    members,
    epoch: 0,  // ‚Üê HARDCODED TO 0
    cipher_suite: input.cipher_suite,
    // ...
})))
```

**Server Behavior:**
- Creates conversation with `current_epoch = 0` (line 168)
- Returns **hardcoded `epoch: 0`** to client
- Server's `current_epoch` doesn't reflect that User A already advanced to Epoch 1 locally

**Client Reaction (THE BUG):**
```swift
// Client receives response
üîÑ Syncing 1 members with server to prevent epoch mismatch...
Added members to conversation: 0c4f12d1... new epoch: 0
‚úÖ Server synchronized at epoch 0
üìä Updated local group state: epoch=0  // ‚Üê INCORRECT!
```

‚ùå **State: App Layer = Epoch 0** (WRONG - trusts server)
‚úÖ **State: FFI = Epoch 1** (CORRECT - knows real state)

**This is the fatal error.** The Swift app regresses its epoch from 1 ‚Üí 0 based on the server's response, creating permanent desynchronization.

---

### Step 4: First Message Send (Masking the Problem)
```
User A sends "hi"
App Layer thinks: Epoch 0
FFI encrypts with: Epoch 1 keys
```

**What Happens:**
1. App layer calls FFI with: `current epoch: 0` (wrong belief)
2. FFI internally uses: `GroupEpoch(1)` (correct state)
3. Message encrypted with **Epoch 1 keys**
4. App sends to server with label: `epoch: 0`

**Server Accepts It (Second Bug):**
```rust
// server/src/handlers/send_message.rs
// NO EPOCH VALIDATION!
let message = db::create_message(
    &pool,
    &input.convo_id,
    &input.msg_id,
    input.ciphertext,
    input.epoch as i64,  // ‚Üê Just stores whatever client sends
    padded_size as i64,
    input.idempotency_key.clone(),
).await?;
```

Server stores message as `seq: 1, epoch: 0` even though it's actually an Epoch 1 ciphertext.

---

### Step 5: User B Joins (Works by Accident)
```
User B receives Welcome message
Welcome is for Epoch 1 (correct)
User B initializes at Epoch 1 ‚úÖ
```

User B's state is correct because they processed the Welcome message that was generated by User A's FFI at Epoch 1.

---

### Step 6: User B Sends Reply (Same Mismatch)
```
User B sends "hi"
App Layer might think: Epoch 0
FFI encrypts with: Epoch 1 keys
Server stores as: epoch 0
```

User B suffers the same app layer / FFI mismatch.

---

### Step 7: User A Returns (Total Failure)
```
User A switches back to conversation
App Layer believes: Epoch 0
FFI state is actually: Epoch 1 (advanced from first send)
```

**Why User A Can't See User B's Message:**
```
Messages already populated, skipping server re-fetch to preserve ratchet state
```

The app doesn't fetch new messages from the server, so it never sees User B's reply.

**Why User A Can't Send New Messages:**
1. App sends message labeled `epoch: 0`
2. FFI has advanced its ratchet further (Epoch 1, generation 2+)
3. Message is encrypted with keys User B doesn't have
4. User B can't decrypt because their ratchet is at a different position

---

## Root Causes

### Primary: Client-Side Trust Issue

**Location:** iOS Swift app's conversation sync logic
**Problem:** Application layer trusts server's `epoch` response over its own MLS FFI state

```swift
// BUG: This code should NOT exist
func syncWithServer(response: CreateConvoResponse) {
    self.currentEpoch = response.epoch  // ‚Üê WRONG!
    // Should be: self.currentEpoch = mlsFFI.getCurrentEpoch()
}
```

**Fix:**
```swift
// The FFI is the source of truth for group state
func syncWithServer(response: CreateConvoResponse) {
    // Verify server knows about the conversation
    self.serverConvoId = response.groupId
    // But DON'T override local epoch
    // self.currentEpoch comes from FFI only
}
```

---

### Secondary: Server-Side Validation Gap

**Location:** `server/src/handlers/send_message.rs`
**Problem:** Server accepts messages with any epoch, no validation

**Current Code:**
```rust
pub async fn send_message(...) {
    // ... membership check ...

    // BUG: No epoch validation!
    let message = db::create_message(
        &pool,
        &input.convo_id,
        &input.msg_id,
        input.ciphertext,
        input.epoch as i64,  // ‚Üê Accepts any value
        // ...
    ).await?;
}
```

**Recommended Architecture Document (CLOUDKIT_MLS_ARCHITECTURE.md) Shows:**
```rust
// Check epoch (prevent replay)
let convo = db::get_conversation(&state.pool, &input.convo_id).await?;
if input.epoch != convo.current_epoch {
    return Err(ApiError::BadRequest(format!(
        "Epoch mismatch: expected {}, got {}",
        convo.current_epoch, input.epoch
    )));
}
```

**But this validation is NOT implemented in production code!**

---

### Tertiary: Server Epoch Tracking

**Location:** `server/src/handlers/create_convo.rs:420`
**Problem:** Server hardcodes `epoch: 0` in response

```rust
Ok(Json(ConvoView::from(ConvoViewData {
    group_id: convo_id,
    creator: creator_did,
    members,
    epoch: 0,  // ‚Üê Always returns 0
    // ...
})))
```

**Issue:** Server's `current_epoch` column doesn't track client-side epoch advancements that happen during group creation.

**When Epoch Advances:**
- Client creates group (epoch 0)
- Client adds members locally (‚Üí epoch 1)
- Client sends `createConvo` with Welcome
- Server stores `current_epoch = 0`
- **Server has no way to know client is at epoch 1**

---

## Design Philosophy Question

**Who is the source of truth for the current epoch?**

### Option A: Server is Authoritative ‚ùå
- Requires server to track every epoch transition
- Doesn't work because:
  1. Client advances epoch locally (adding members)
  2. Server only sees the result (Welcome message)
  3. Server can't know what epoch the Welcome is for without parsing it

### Option B: Client FFI is Authoritative ‚úÖ
- **This is the correct answer**
- Client's OpenMLS state machine is the ground truth
- Server's `current_epoch` is:
  - A checkpoint for consistency checks
  - NOT the source of truth for client state
  - Updated when server processes commits (future feature)

---

## Fixes Required

### Fix 1: Client - Stop Trusting Server Epoch (CRITICAL)

**File:** iOS Swift app conversation manager
**Change:** Remove any code that overwrites local epoch from server responses

```swift
// BEFORE (WRONG):
func handleCreateConvoResponse(_ response: CreateConvoResponse) {
    self.currentEpoch = response.epoch  // ‚Üê DELETE THIS
    self.groupId = response.groupId
}

// AFTER (CORRECT):
func handleCreateConvoResponse(_ response: CreateConvoResponse) {
    self.groupId = response.groupId
    // epoch comes from MLSContext.getCurrentEpoch() only
}
```

**Principle:** Application layer should NEVER override the FFI's epoch. The FFI is the single source of truth.

---

### Fix 2: Server - Add Epoch Validation (DEFENSE IN DEPTH)

**File:** `server/src/handlers/send_message.rs:107`
**Add after membership check:**

```rust
// Check if sender is a member
if !is_member(&pool, &auth_user.did, &input.convo_id).await? {
    return Err(StatusCode::FORBIDDEN);
}

// NEW: Validate epoch matches server's expectation
let convo = sqlx::query_as::<_, crate::models::Conversation>(
    "SELECT id, creator_did, current_epoch, created_at, updated_at, name, cipher_suite
     FROM conversations WHERE id = $1"
)
.bind(&input.convo_id)
.fetch_one(&pool)
.await
.map_err(|e| {
    error!("Failed to fetch conversation: {}", e);
    StatusCode::INTERNAL_SERVER_ERROR
})?;

if input.epoch != convo.current_epoch as u32 {
    error!(
        "Epoch mismatch: conversation {} is at epoch {}, but client sent epoch {}",
        input.convo_id, convo.current_epoch, input.epoch
    );
    return Err(StatusCode::CONFLICT); // 409 Conflict
}
```

**Benefits:**
- Catches desynchronization early
- Prevents "impossible" messages from being stored
- Forces client to fix its state

**Note:** This will initially break User A's client until Fix 1 is applied.

---

### Fix 3: Client - Fetch Messages on Return (USABILITY)

**Problem:** When User A switches back, app doesn't fetch new messages

```
Messages already populated, skipping server re-fetch to preserve ratchet state
```

**Fix:** Always poll for new messages when entering a conversation view, even if messages are cached.

```swift
func viewDidAppear() {
    // ALWAYS fetch latest messages
    Task {
        await fetchNewMessages()
    }
}
```

---

## Testing the Fixes

### Test Case 1: Create & Send
```
1. User A creates group, adds User B
2. User A sends message
   - Verify: Message labeled with correct epoch (should be 1, not 0)
   - Verify: Server accepts or rejects appropriately
3. User B receives and decrypts
   - Verify: Success
```

### Test Case 2: Round-Trip Communication
```
1. User A creates group, adds User B
2. User A sends "hi"
3. User B receives and replies "hello"
4. User A switches away and back
   - Verify: Sees User B's reply
5. User A sends "thanks"
   - Verify: User B receives and decrypts
```

### Test Case 3: Epoch Mismatch Rejection
```
1. User A creates group
2. Manually craft message with epoch=99
3. Send to server
   - Verify: Server rejects with 409 Conflict
```

---

## Long-Term: Server Epoch Tracking

The server's `current_epoch` should eventually track real epoch transitions when commits are processed server-side. This requires:

1. **Commit Processing:** Server parses MLS commit messages
2. **Epoch Advancement:** Server updates `current_epoch` when processing commits
3. **State Reconstruction:** Server can validate messages against actual group state

**Current State:** Server treats messages as opaque ciphertexts (good for privacy, bad for validation)
**Future State:** Server can validate epochs without seeing plaintext (only MLS metadata)

---

## Summary

**The Bug:**
1. Client FFI advances to Epoch 1 when adding member
2. Server returns Epoch 0 (hardcoded)
3. Client app trusts server and regresses to Epoch 0
4. Client FFI remains at Epoch 1
5. Permanent desynchronization between app layer (0) and crypto layer (1)

**The Fixes:**
1. **Client:** Never trust server's epoch - FFI is source of truth
2. **Server:** Validate epochs in `send_message` (defense in depth)
3. **Client:** Always fetch messages when returning to conversation

**Priority:** Fix #1 (client trust issue) is CRITICAL and must be deployed immediately.
